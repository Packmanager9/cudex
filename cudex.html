<!DOCTYPE html>

<html lang="en" dir="ltr">

<head>
    <meta http-equiv="Content-Security-Policy" content="
  default-src 'self';
  script-src 'self' 'unsafe-inline';
  style-src 'self' 'unsafe-inline';
  img-src 'self' http://localhost:3000;
  connect-src 'self' http://localhost:3000;
  font-src 'self';
">
    <!-- <link rel="stylesheet" href="styles.css"> -->

    <style> 
        ::-webkit-scrollbar {
        display: none;
    }
        html, body, div, canvas {
          margin: 0;
          padding: 0;
      }

      html, body {
    margin: 0;
    padding: 0;
    overflow: hidden; /* Optional: Prevents scrolling */
}
canvas {
    position: absolute;
    top: 0;
    left: 0;
}
      </style>
</head>

<canvas hidden style="touch-action: none;"  id="realcanvas" width="1280" height="850" class="canvas"></canvas>
<canvas  id="canvas" width="700" height="700"></canvas>
<canvas hidden id="canvas2" width="700" height="700"></canvas>
<script>
// window.addEventListener('DOMContentLoaded', (event) => {
    const squaretable = {} // this section of code is an optimization for use of the hypotenuse function on Line and LineOP objects
for (let t = 0; t < 10000000; t++) {
    squaretable[`${t}`] = Math.sqrt(t)
    if (t > 999) {
        t += 9
    }
}
let video_recorder
let recording = 0
// function CanvasCaptureToWEBM(canvas, bitrate) {
//     // the video_recorder is set to  '= new CanvasCaptureToWEBM(canvas, 4500000);' in the setup, 
//     // it uses the same canvas as the rest of the file.
//     // to start a recording call .record() on video_recorder
//     /*
//     for example, 
//     if(keysPressed['-'] && recording == 0){
//         recording = 1
//         video_recorder.record()
//     }
//     if(keysPressed['='] && recording == 1){
//         recording = 0
//         video_recorder.stop()
//         video_recorder.download('File Name As A String.webm')
//     }
//     */
//     this.record = Record
//     this.stop = Stop
//     this.download = saveToDownloads
//     let blobCaptures = []
//     let outputFormat = {}
//     let recorder = {}
//     let canvasInput = canvas.captureStream()
//     if (typeof canvasInput == undefined || !canvasInput) {
//         return
//     }
//     const video = document.createElement('video')
//     video.style.display = 'none'

//     function Record() {
//         let formats = [
//             'video/vp8',
//             "video/webm",
//             'video/webm,codecs=vp9',
//             "video/webm\;codecs=vp8",
//             "video/webm\;codecs=daala",
//             "video/webm\;codecs=h264",
//             "video/mpeg"
//         ];

//         for (let t = 0;t<formats.length;t++) {
//             if (MediaRecorder.isTypeSupported(formats[t])) {
//                 outputFormat = formats[t]
//                 break
//             }
//         }
//         if (typeof outputFormat != "string") {
//             return
//         }else{
//             let videoSettings = {
//                 mimeType: outputFormat,
//                 videoBitsPerSecond: bitrate || 2000000 // 2Mbps
//             };
//             blobCaptures = []
//             try {
//                 recorder = new MediaRecorder(canvasInput, videoSettings)
//             } catch (error) {
//                 return;
//             }
//             recorder.onstop = handleStop
//             recorder.ondataavailable = handleAvailableData
//             recorder.start(100)
//         } 
//     }
//     function handleAvailableData(event) {
//         if (event.data && event.data.size > 0) {
//             blobCaptures.push(event.data)
//         }
//     }
//     function handleStop() {
//         const superBuffer = new Blob(blobCaptures, { type: outputFormat })
//         video.src = window.URL.createObjectURL(superBuffer)
//     }
//     function Stop() {
//         recorder.stop()
//         video.controls = true
//     }
//     function saveToDownloads(input) { // specifying a file name for the output
//         const name = input || 'video_out.webm'
//         const blob = new Blob(blobCaptures, { type: outputFormat })
//         const url = window.URL.createObjectURL(blob)
//         const storageElement = document.createElement('a')
//         storageElement.style.display = 'none'
//         storageElement.href = url
//         storageElement.download = name
//         document.body.appendChild(storageElement)
//         storageElement.click()
//         setTimeout(() => {
//             document.body.removeChild(storageElement)
//             window.URL.revokeObjectURL(url)
//         }, 100)
//     }
// }
const gamepadAPI = {
    controller: {},
    turbo: true,
    connect: function(evt) {
        if (navigator.getGamepads()[0] != null) {
            gamepadAPI.controller = navigator.getGamepads()[0]
            gamepadAPI.turbo = true;
        } else if (navigator.getGamepads()[1] != null) {
            gamepadAPI.controller = navigator.getGamepads()[0]
            gamepadAPI.turbo = true;
        } else if (navigator.getGamepads()[2] != null) {
            gamepadAPI.controller = navigator.getGamepads()[0]
            gamepadAPI.turbo = true;
        } else if (navigator.getGamepads()[3] != null) {
            gamepadAPI.controller = navigator.getGamepads()[0]
            gamepadAPI.turbo = true;
        }
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i] === null) {
                continue;
            }
            if (!gamepads[i].connected) {
                continue;
            }
        }
    },
    disconnect: function(evt) {
        gamepadAPI.turbo = false;
        delete gamepadAPI.controller;
    },
    update: function() {
        gamepadAPI.controller = navigator.getGamepads()[0]
        gamepadAPI.buttonsCache = []; // clear the buttons cache
        for (var k = 0; k < gamepadAPI.buttonsStatus.length; k++) { // move the buttons status from the previous frame to the cache
            gamepadAPI.buttonsCache[k] = gamepadAPI.buttonsStatus[k];
        }
        gamepadAPI.buttonsStatus = []; // clear the buttons status
        var c = gamepadAPI.controller || {}; // get the gamepad object
        var pressed = [];
        if (c.buttons) {
            for (var b = 0, t = c.buttons.length; b < t; b++) { // loop through buttons and push the pressed ones to the array
                if (c.buttons[b].pressed) {
                    pressed.push(gamepadAPI.buttons[b]);
                }
            }
        }
        var axes = [];
        if (c.axes) {
            for (var a = 0, x = c.axes.length; a < x; a++) { // loop through axes and push their values to the array
                axes.push(c.axes[a].toFixed(2));
            }
        }
        gamepadAPI.axesStatus = axes; // assign received values
        gamepadAPI.buttonsStatus = pressed;
        // //console.log(pressed); // return buttons for debugging purposes
        return pressed;
    },
    buttonPressed: function(button, hold) {
        var newPress = false;
        for (var i = 0, s = gamepadAPI.buttonsStatus.length; i < s; i++) { // loop through pressed buttons
            if (gamepadAPI.buttonsStatus[i] == button) { // if we found the button we're looking for...
                newPress = true; // set the boolean variable to true
                if (!hold) { // if we want to check the single press
                    for (var j = 0, p = gamepadAPI.buttonsCache.length; j < p; j++) { // loop through the cached states from the previous frame
                        if (gamepadAPI.buttonsCache[j] == button) { // if the button was already pressed, ignore new press
                            newPress = false;
                        }
                    }
                }
            }
        }
        return newPress;
    },
    buttons: [
        'A', 'B', 'X', 'Y', 'LB', 'RB', 'Left-Trigger', 'Right-Trigger', 'Back', 'Start', 'Axis-Left', 'Axis-Right', 'DPad-Up', 'DPad-Down', 'DPad-Left', 'DPad-Right', "Power"
    ],
    buttonsCache: [],
    buttonsStatus: [],
    axesStatus: []
};
let canvas
let canvas_context
let keysPressed = {}
let FLEX_engine
let TIP_engine = {}
let XS_engine
let YS_engine
class Point {
    constructor(x, y) {
        this.x = x
        this.y = y
        this.radius = 0
    }
    pointDistance(point) {
        return (new LineOP(this, point, "transparent", 0)).hypotenuse()
    }
}

class Vector { // vector math and physics if you prefer this over vector components on circles
    constructor(object = (new Point(0, 0)), xmom = 0, ymom = 0) {
        this.xmom = xmom
        this.ymom = ymom
        this.object = object
    }
    isToward(point) {
        let link = new LineOP(this.object, point)
        let dis1 = link.squareDistance()
        let dummy = new Point(this.object.x + this.xmom, this.object.y + this.ymom)
        let link2 = new LineOP(dummy, point)
        let dis2 = link2.squareDistance()
        if (dis2 < dis1) {
            return true
        } else {
            return false
        }
    }
    rotate(angleGoal) {
        let link = new Line(this.xmom, this.ymom, 0, 0)
        let length = link.hypotenuse()
        let x = (length * Math.cos(angleGoal))
        let y = (length * Math.sin(angleGoal))
        this.xmom = x
        this.ymom = y
    }
    magnitude() {
        return (new Line(this.xmom, this.ymom, 0, 0)).hypotenuse()
    }
    normalize(size = 1) {
        let magnitude = this.magnitude()
        this.xmom /= magnitude
        this.ymom /= magnitude
        this.xmom *= size
        this.ymom *= size
    }
    multiply(vect) {
        let point = new Point(0, 0)
        let end = new Point(this.xmom + vect.xmom, this.ymom + vect.ymom)
        return point.pointDistance(end)
    }
    add(vect) {
        return new Vector(this.object, this.xmom + vect.xmom, this.ymom + vect.ymom)
    }
    subtract(vect) {
        return new Vector(this.object, this.xmom - vect.xmom, this.ymom - vect.ymom)
    }
    divide(vect) {
        return new Vector(this.object, this.xmom / vect.xmom, this.ymom / vect.ymom) //be careful with this, I don't think this is right
    }
    draw() {
        let dummy = new Point(this.object.x + this.xmom, this.object.y + this.ymom)
        let link = new LineOP(this.object, dummy, "#FFFFFF", 1)
        link.draw()
    }
}
class Line {
    constructor(x, y, x2, y2, color, width) {
        this.x1 = x
        this.y1 = y
        this.x2 = x2
        this.y2 = y2
        this.color = color
        this.width = width
    }
    angle() {
        return Math.atan2(this.y1 - this.y2, this.x1 - this.x2)
    }
    squareDistance() {
        let xdif = this.x1 - this.x2
        let ydif = this.y1 - this.y2
        let squareDistance = (xdif * xdif) + (ydif * ydif)
        return squareDistance
    }
    hypotenuse() {
        let xdif = this.x1 - this.x2
        let ydif = this.y1 - this.y2
        let hypotenuse = (xdif * xdif) + (ydif * ydif)
        if (hypotenuse < 10000000 - 1) {
            if (hypotenuse > 1000) {
                return squaretable[`${Math.round(10 * Math.round((hypotenuse * .1)))}`]
            } else {
                return squaretable[`${Math.round(hypotenuse)}`]
            }
        } else {
            return Math.sqrt(hypotenuse)
        }
    }
    draw() {
        let linewidthstorage = canvas_context.lineWidth
        canvas_context.strokeStyle = this.color
        canvas_context.lineWidth = this.width
        canvas_context.beginPath()
        canvas_context.moveTo(this.x1, this.y1)
        canvas_context.lineTo(this.x2, this.y2)
        canvas_context.stroke()
        canvas_context.lineWidth = linewidthstorage
    }
}
class LineOP {
    constructor(object, target, color, width) {
        this.object = object
        this.target = target
        this.color = color
        this.width = width
    }
    squareDistance() {
        let xdif = this.object.x - this.target.x
        let ydif = this.object.y - this.target.y
        let squareDistance = (xdif * xdif) + (ydif * ydif)
        return squareDistance
    }
    hypotenuse() {
        let xdif = this.object.x - this.target.x
        let ydif = this.object.y - this.target.y
        let hypotenuse = (xdif * xdif) + (ydif * ydif)
        if (hypotenuse < 10000000 - 1) {
            if (hypotenuse > 1000) {
                return squaretable[`${Math.round(10 * Math.round((hypotenuse * .1)))}`]
            } else {
                return squaretable[`${Math.round(hypotenuse)}`]
            }
        } else {
            return Math.sqrt(hypotenuse)
        }
    }
    angle() {
        return Math.atan2(this.object.y - this.target.y, this.object.x - this.target.x)
    }
    draw() {
        let linewidthstorage = canvas_context.lineWidth
        canvas_context.strokeStyle = this.color
        canvas_context.lineWidth = this.width
        canvas_context.beginPath()
        canvas_context.moveTo(this.object.x * 120 + 350, this.object.y * 120 + 350)
        canvas_context.lineTo(this.target.x * 120 + 350, this.target.y * 120 + 350)
        canvas_context.stroke()
        canvas_context.lineWidth = linewidthstorage
    }
}
class Triangle {
    constructor(x, y, color, length, fill = 0, strokeWidth = 0, leg1Ratio = 1, leg2Ratio = 1, heightRatio = 1) {
        this.x = x
        this.y = y
        this.color = color
        this.length = length
        this.x1 = this.x + this.length * leg1Ratio
        this.x2 = this.x - this.length * leg2Ratio
        this.tip = this.y - this.length * heightRatio
        this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
        this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
        this.fill = fill
        this.stroke = strokeWidth
    }
    draw() {
        canvas_context.strokeStyle = this.color
        canvas_context.stokeWidth = this.stroke
        canvas_context.beginPath()
        canvas_context.moveTo(this.x, this.y)
        canvas_context.lineTo(this.x1, this.y)
        canvas_context.lineTo(this.x, this.tip)
        canvas_context.lineTo(this.x2, this.y)
        canvas_context.lineTo(this.x, this.y)
        if (this.fill == 1) {
            canvas_context.fill()
        }
        canvas_context.stroke()
        canvas_context.closePath()
    }
    isPointInside(point) {
        if (point.x <= this.x1) {
            if (point.y >= this.tip) {
                if (point.y <= this.y) {
                    if (point.x >= this.x2) {
                        this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
                        this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
                        this.basey = point.y - this.tip
                        this.basex = point.x - this.x
                        if (this.basex == 0) {
                            return true
                        }
                        this.slope = this.basey / this.basex
                        if (this.slope >= this.accept1) {
                            return true
                        } else if (this.slope <= this.accept2) {
                            return true
                        }
                    }
                }
            }
        }
        return false
    }
}
class Rectangle {
    constructor(x, y, width, height, color, fill = 1, stroke = 0, strokeWidth = 1) {
        this.x = x
        this.y = y
        this.height = height
        this.width = width
        this.color = color
        this.xmom = 0
        this.ymom = 0
        this.stroke = stroke
        this.strokeWidth = strokeWidth
        this.fill = fill
    }
    draw() {
        canvas_context.fillStyle = this.color
        canvas_context.fillRect(this.x, this.y, this.width, this.height)
    }
    move() {
        this.x += this.xmom
        this.y += this.ymom
    }
    isPointInside(point) {
        if (point.x >= this.x) {
            if (point.y >= this.y) {
                if (point.x <= this.x + this.width) {
                    if (point.y <= this.y + this.height) {
                        return true
                    }
                }
            }
        }
        return false
    }
    doesPerimeterTouch(point) {
        if (point.x + point.radius >= this.x) {
            if (point.y + point.radius >= this.y) {
                if (point.x - point.radius <= this.x + this.width) {
                    if (point.y - point.radius <= this.y + this.height) {
                        return true
                    }
                }
            }
        }
        return false
    }
}
class Circle {
    constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
        this.x = x
        this.y = y
        this.radius = radius
        this.color = color
        this.xmom = xmom
        this.ymom = ymom
        this.friction = friction
        this.reflect = reflect
        this.strokeWidth = strokeWidth
        this.strokeColor = strokeColor
    }
    draw() {
        canvas_context.lineWidth = 2
        canvas_context.strokeStyle = "black"
        canvas_context.beginPath();
        if (this.radius > 0) {
            canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
            canvas_context.fillStyle = this.color
            canvas_context.fill()
            canvas_context.stroke();
        } else {
            //console.l\og("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
        }
    }
    move() {
        if (this.reflect == 1) {
            if (this.x + this.radius > canvas.width) {
                if (this.xmom > 0) {
                    this.xmom *= -1
                }
            }
            if (this.y + this.radius > canvas.height) {
                if (this.ymom > 0) {
                    this.ymom *= -1
                }
            }
            if (this.x - this.radius < 0) {
                if (this.xmom < 0) {
                    this.xmom *= -1
                }
            }
            if (this.y - this.radius < 0) {
                if (this.ymom < 0) {
                    this.ymom *= -1
                }
            }
        }
        this.x += this.xmom
        this.y += this.ymom
    }
    unmove() {
        if (this.reflect == 1) {
            if (this.x + this.radius > canvas.width) {
                if (this.xmom > 0) {
                    this.xmom *= -1
                }
            }
            if (this.y + this.radius > canvas.height) {
                if (this.ymom > 0) {
                    this.ymom *= -1
                }
            }
            if (this.x - this.radius < 0) {
                if (this.xmom < 0) {
                    this.xmom *= -1
                }
            }
            if (this.y - this.radius < 0) {
                if (this.ymom < 0) {
                    this.ymom *= -1
                }
            }
        }
        this.x -= this.xmom
        this.y -= this.ymom
    }
    frictiveMove() {
        if (this.reflect == 1) {
            if (this.x + this.radius > canvas.width) {
                if (this.xmom > 0) {
                    this.xmom *= -1
                }
            }
            if (this.y + this.radius > canvas.height) {
                if (this.ymom > 0) {
                    this.ymom *= -1
                }
            }
            if (this.x - this.radius < 0) {
                if (this.xmom < 0) {
                    this.xmom *= -1
                }
            }
            if (this.y - this.radius < 0) {
                if (this.ymom < 0) {
                    this.ymom *= -1
                }
            }
        }
        this.x += this.xmom
        this.y += this.ymom
        this.xmom *= this.friction
        this.ymom *= this.friction
    }
    frictiveunMove() {
        if (this.reflect == 1) {
            if (this.x + this.radius > canvas.width) {
                if (this.xmom > 0) {
                    this.xmom *= -1
                }
            }
            if (this.y + this.radius > canvas.height) {
                if (this.ymom > 0) {
                    this.ymom *= -1
                }
            }
            if (this.x - this.radius < 0) {
                if (this.xmom < 0) {
                    this.xmom *= -1
                }
            }
            if (this.y - this.radius < 0) {
                if (this.ymom < 0) {
                    this.ymom *= -1
                }
            }
        }
        this.xmom /= this.friction
        this.ymom /= this.friction
        this.x -= this.xmom
        this.y -= this.ymom
    }
    isPointInside(point) {
        this.areaY = point.y - this.y
        this.areaX = point.x - this.x
        if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
            return true
        }
        return false
    }
    doesPerimeterTouch(point) {
        this.areaY = point.y - this.y
        this.areaX = point.x - this.x
        if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
            return true
        }
        return false
    }
}
class Polygon {
    constructor(x, y, size, color, sides = 3, xmom = 0, ymom = 0, angle = 0, reflect = 0) {
        if (sides < 2) {
            sides = 2
        }
        this.reflect = reflect
        this.xmom = xmom
        this.ymom = ymom
        this.body = new Circle(x, y, size - (size * .293), "transparent")
        this.nodes = []
        this.angle = angle
        this.size = size
        this.color = color
        this.angleIncrement = (Math.PI * 2) / sides
        this.sides = sides
        for (let t = 0; t < sides; t++) {
            let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
            this.nodes.push(node)
            this.angle += this.angleIncrement
        }
    }
    isPointInside(point) { // rough approximation
        this.body.radius = this.size - (this.size * .293)
        if (this.sides <= 2) {
            return false
        }
        this.areaY = point.y - this.body.y
        this.areaX = point.x - this.body.x
        if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.body.radius * this.body.radius)) {
            return true
        }
        return false
    }
    move() {
        if (this.reflect == 1) {
            if (this.body.x > canvas.width) {
                if (this.xmom > 0) {
                    this.xmom *= -1
                }
            }
            if (this.body.y > canvas.height) {
                if (this.ymom > 0) {
                    this.ymom *= -1
                }
            }
            if (this.body.x < 0) {
                if (this.xmom < 0) {
                    this.xmom *= -1
                }
            }
            if (this.body.y < 0) {
                if (this.ymom < 0) {
                    this.ymom *= -1
                }
            }
        }
        this.body.x += this.xmom
        this.body.y += this.ymom
    }
    draw() {
        this.nodes = []
        this.angleIncrement = (Math.PI * 2) / this.sides
        this.body.radius = this.size - (this.size * .293)
        for (let t = 0; t < this.sides; t++) {
            let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
            this.nodes.push(node)
            this.angle += this.angleIncrement
        }
        canvas_context.strokeStyle = this.color
        canvas_context.fillStyle = this.color
        canvas_context.lineWidth = 0
        canvas_context.beginPath()
        canvas_context.moveTo(this.nodes[0].x, this.nodes[0].y)
        for (let t = 1; t < this.nodes.length; t++) {
            canvas_context.lineTo(this.nodes[t].x, this.nodes[t].y)
        }
        canvas_context.lineTo(this.nodes[0].x, this.nodes[0].y)
        canvas_context.fill()
        canvas_context.stroke()
        canvas_context.closePath()
    }
}
class Shape {
    constructor(shapes) {
        this.shapes = shapes
    }
    draw() {
        for (let t = 0; t < this.shapes.length; t++) {
            this.shapes[t].draw()
        }
    }
    isPointInside(point) {
        for (let t = 0; t < this.shapes.length; t++) {
            if (this.shapes[t].isPointInside(point)) {
                return true
            }
        }
        return false
    }
    doesPerimeterTouch(point) {
        for (let t = 0; t < this.shapes.length; t++) {
            if (this.shapes[t].doesPerimeterTouch(point)) {
                return true
            }
        }
        return false
    }
    innerShape(point) {
        for (let t = 0; t < this.shapes.length; t++) {
            if (this.shapes[t].doesPerimeterTouch(point)) {
                return this.shapes[t]
            }
        }
        return false
    }
    isInsideOf(box) {
        for (let t = 0; t < this.shapes.length; t++) {
            if (box.isPointInside(this.shapes[t])) {
                return true
            }
        }
        return false
    }
    adjustByFromDisplacement(x, y) {
        for (let t = 0; t < this.shapes.length; t++) {
            if (typeof this.shapes[t].fromRatio == "number") {
                this.shapes[t].x += x * this.shapes[t].fromRatio
                this.shapes[t].y += y * this.shapes[t].fromRatio
            }
        }
    }
    adjustByToDisplacement(x, y) {
        for (let t = 0; t < this.shapes.length; t++) {
            if (typeof this.shapes[t].toRatio == "number") {
                this.shapes[t].x += x * this.shapes[t].toRatio
                this.shapes[t].y += y * this.shapes[t].toRatio
            }
        }
    }
    mixIn(arr) {
        for (let t = 0; t < arr.length; t++) {
            for (let k = 0; k < arr[t].shapes.length; k++) {
                this.shapes.push(arr[t].shapes[k])
            }
        }
    }
    push(object) {
        this.shapes.push(object)
    }
}

class Spring {
    constructor(x, y, radius, color, body = 0, length = 1, gravity = 0, width = 1) {
        if (body == 0) {
            this.body = new Circle(x, y, radius, color)
            this.anchor = new Circle(x, y, radius, color)
            this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
            this.length = length
        } else {
            this.body = body
            this.anchor = new Circle(x, y, radius, color)
            this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
            this.length = length
        }
        this.gravity = gravity
        this.width = width
    }
    balance() {
        this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
        if (this.beam.hypotenuse() < this.length) {
            this.body.xmom += (this.body.x - this.anchor.x) / this.length
            this.body.ymom += (this.body.y - this.anchor.y) / this.length
            this.anchor.xmom -= (this.body.x - this.anchor.x) / this.length
            this.anchor.ymom -= (this.body.y - this.anchor.y) / this.length
        } else {
            this.body.xmom -= (this.body.x - this.anchor.x) / this.length
            this.body.ymom -= (this.body.y - this.anchor.y) / this.length
            this.anchor.xmom += (this.body.x - this.anchor.x) / this.length
            this.anchor.ymom += (this.body.y - this.anchor.y) / this.length
        }
        let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
        let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
        this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
        this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
        this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
        this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
    }
    draw() {
        this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
        this.beam.draw()
        this.body.draw()
        this.anchor.draw()
    }
    move() {
        this.anchor.ymom += this.gravity
        this.anchor.move()
    }

}
class SpringOP {
    constructor(body, anchor, length, width = 3, color = body.color) {
        this.body = body
        this.anchor = anchor
        this.beam = new LineOP(body, anchor, color, width)
        this.length = length
    }
    balance() {
        if (this.beam.hypotenuse() < this.length) {
            this.body.xmom += ((this.body.x - this.anchor.x) / this.length)
            this.body.ymom += ((this.body.y - this.anchor.y) / this.length)
            this.anchor.xmom -= ((this.body.x - this.anchor.x) / this.length)
            this.anchor.ymom -= ((this.body.y - this.anchor.y) / this.length)
        } else if (this.beam.hypotenuse() > this.length) {
            this.body.xmom -= (this.body.x - this.anchor.x) / (this.length)
            this.body.ymom -= (this.body.y - this.anchor.y) / (this.length)
            this.anchor.xmom += (this.body.x - this.anchor.x) / (this.length)
            this.anchor.ymom += (this.body.y - this.anchor.y) / (this.length)
        }

        let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
        let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
        this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
        this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
        this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
        this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
    }
    draw() {
        this.beam.draw()
    }
    move() {
        //movement of SpringOP objects should be handled separate from their linkage, to allow for many connections, balance here with this object, move nodes independently
    }
}

class Color {
    constructor(baseColor, red = -1, green = -1, blue = -1, alpha = 1) {
        this.hue = baseColor
        if (red != -1 && green != -1 && blue != -1) {
            this.r = red
            this.g = green
            this.b = blue
            if (alpha != 1) {
                if (alpha < 1) {
                    this.alpha = alpha
                } else {
                    this.alpha = alpha / 255
                    if (this.alpha > 1) {
                        this.alpha = 1
                    }
                }
            }
            if (this.r > 255) {
                this.r = 255
            }
            if (this.g > 255) {
                this.g = 255
            }
            if (this.b > 255) {
                this.b = 255
            }
            if (this.r < 0) {
                this.r = 0
            }
            if (this.g < 0) {
                this.g = 0
            }
            if (this.b < 0) {
                this.b = 0
            }
        } else {
            this.r = 0
            this.g = 0
            this.b = 0
        }
    }
    normalize() {
        if (this.r > 255) {
            this.r = 255
        }
        if (this.g > 255) {
            this.g = 255
        }
        if (this.b > 255) {
            this.b = 255
        }
        if (this.r < 0) {
            this.r = 0
        }
        if (this.g < 0) {
            this.g = 0
        }
        if (this.b < 0) {
            this.b = 0
        }
    }
    randomLight() {
        var letters = '0123456789ABCDEF';
        var hash = '#';
        for (var i = 0; i < 6; i++) {
            hash += letters[(Math.floor(Math.random() * 12) + 4)];
        }
        var color = new Color(hash, 55 + Math.random() * 200, 55 + Math.random() * 200, 55 + Math.random() * 200)
        return color;
    }
    randomDark() {
        var letters = '0123456789ABCDEF';
        var hash = '#';
        for (var i = 0; i < 6; i++) {
            hash += letters[(Math.floor(Math.random() * 12))];
        }
        var color = new Color(hash, Math.random() * 200, Math.random() * 200, Math.random() * 200)
        return color;
    }
    random() {
        var letters = '0123456789ABCDEF';
        var hash = '#';
        for (var i = 0; i < 6; i++) {
            hash += letters[(Math.floor(Math.random() * 16))];
        }
        var color = new Color(hash, Math.random() * 255, Math.random() * 255, Math.random() * 255)
        return color;
    }
}
class Softbody { //buggy, spins in place
    constructor(x, y, radius, color, members = 10, memberLength = 5, force = 10, gravity = 0) {
        this.springs = []
        this.pin = new Circle(x, y, radius, color)
        this.spring = new Spring(x, y, radius, color, this.pin, memberLength, gravity)
        this.springs.push(this.spring)
        for (let k = 0; k < members; k++) {
            this.spring = new Spring(x, y, radius, color, this.spring.anchor, memberLength, gravity)
            if (k < members - 1) {
                this.springs.push(this.spring)
            } else {
                this.spring.anchor = this.pin
                this.springs.push(this.spring)
            }
        }
        this.forceConstant = force
        this.centroid = new Point(0, 0)
    }
    circularize() {
        this.xpoint = 0
        this.ypoint = 0
        for (let s = 0; s < this.springs.length; s++) {
            this.xpoint += (this.springs[s].anchor.x / this.springs.length)
            this.ypoint += (this.springs[s].anchor.y / this.springs.length)
        }
        this.centroid.x = this.xpoint
        this.centroid.y = this.ypoint
        this.angle = 0
        this.angleIncrement = (Math.PI * 2) / this.springs.length
        for (let t = 0; t < this.springs.length; t++) {
            this.springs[t].body.x = this.centroid.x + (Math.cos(this.angle) * this.forceConstant)
            this.springs[t].body.y = this.centroid.y + (Math.sin(this.angle) * this.forceConstant)
            this.angle += this.angleIncrement
        }
    }
    balance() {
        for (let s = this.springs.length - 1; s >= 0; s--) {
            this.springs[s].balance()
        }
        this.xpoint = 0
        this.ypoint = 0
        for (let s = 0; s < this.springs.length; s++) {
            this.xpoint += (this.springs[s].anchor.x / this.springs.length)
            this.ypoint += (this.springs[s].anchor.y / this.springs.length)
        }
        this.centroid.x = this.xpoint
        this.centroid.y = this.ypoint
        for (let s = 0; s < this.springs.length; s++) {
            this.link = new Line(this.centroid.x, this.centroid.y, this.springs[s].anchor.x, this.springs[s].anchor.y, 0, "transparent")
            if (this.link.hypotenuse() != 0) {
                this.springs[s].anchor.xmom += (((this.springs[s].anchor.x - this.centroid.x) / (this.link.hypotenuse()))) * this.forceConstant
                this.springs[s].anchor.ymom += (((this.springs[s].anchor.y - this.centroid.y) / (this.link.hypotenuse()))) * this.forceConstant
            }
        }
        for (let s = 0; s < this.springs.length; s++) {
            this.springs[s].move()
        }
        for (let s = 0; s < this.springs.length; s++) {
            this.springs[s].draw()
        }
    }
}
class Observer {
    constructor(x, y, radius, color, range = 100, rays = 10, angle = (Math.PI * .125)) {
        this.body = new Circle(x, y, radius, color)
        this.color = color
        this.ray = []
        this.rayrange = range
        this.globalangle = Math.PI
        this.gapangle = angle
        this.currentangle = 0
        this.obstacles = []
        this.raymake = rays
    }
    beam() {
        this.currentangle = this.gapangle / 2
        for (let k = 0; k < this.raymake; k++) {
            this.currentangle += (this.gapangle / Math.ceil(this.raymake / 2))
            let ray = new Circle(this.body.x, this.body.y, 1, "white", (((Math.cos(this.globalangle + this.currentangle)))), (((Math.sin(this.globalangle + this.currentangle)))))
            ray.collided = 0
            ray.lifespan = this.rayrange - 1
            this.ray.push(ray)
        }
        for (let f = 0; f < this.rayrange; f++) {
            for (let t = 0; t < this.ray.length; t++) {
                if (this.ray[t].collided < 1) {
                    this.ray[t].move()
                    for (let q = 0; q < this.obstacles.length; q++) {
                        if (this.obstacles[q].isPointInside(this.ray[t])) {
                            this.ray[t].collided = 1
                        }
                    }
                }
            }
        }
    }
    draw() {
        this.beam()
        this.body.draw()
        canvas_context.lineWidth = 1
        canvas_context.fillStyle = this.color
        canvas_context.strokeStyle = this.color
        canvas_context.beginPath()
        canvas_context.moveTo(this.body.x, this.body.y)
        for (let y = 0; y < this.ray.length; y++) {
            canvas_context.lineTo(this.ray[y].x, this.ray[y].y)
            canvas_context.lineTo(this.body.x, this.body.y)
        }
        canvas_context.stroke()
        canvas_context.fill()
        this.ray = []
    }
}

function setUp(canvas_pass, style = "#000000") {
    canvas = canvas_pass
    // video_recorder = new CanvasCaptureToWEBM(canvas, 4500000);
    canvas_context = canvas.getContext('2d');
    canvas.style.background = style
    window.setInterval(function() {
        main()
    }, 40)

    let selected = null;

    window.addEventListener("pointerdown", e => {
        FLEX_engine = canvas.getBoundingClientRect();
        XS_engine = e.clientX - FLEX_engine.left;
        YS_engine = e.clientY - FLEX_engine.top;
        TIP_engine.x = XS_engine
        TIP_engine.y = YS_engine
        TIP_engine.body = TIP_engine

        if(goRect.isPointInside(TIP_engine)){
            startgame = 1
        }
        const hit = grid.isPointInside(TIP_engine, 7); // 12px tolerance

        // if(hit.type == 0 ){
        //     return
        // }
        if (hit.type == 1 && grid.turn == -1) {

            let sup = 0
            grid.dots.map(d => {
                // if(d.selected == 1){

                //     // d.selected = 2
                //     // sup = 1
                // }else{

                d.selected = -1
                // }
            })

        } else if (hit.type == 2 && grid.turn == 1) {

            let sup = 0
            grid.dots.map(d => {
                // if(d.selected == 1){

                //     // d.selected = 2
                //     // sup = 1
                // }else{

                d.selected = -1
                // }
            })

        } else {

            let sup = 0
            grid.dots.map(d => {
                if (d.selected == 1) {

                    d.selected = 2
                    sup = 1
                } else {

                    d.selected = -1
                }
            })


            if (sup == 0) {

                return
            }
        }


        if (hit) {
            
            selected = hit;
            console.log("Selected point:", hit);
            hit.selected = 1

            console.log(hit.subtype)
            let x = hit.k
            let z = hit.e
            let y = hit.t

            let glob = 1
            grid.dots.map(d => {
                if (grid.turn == -1 && d.type == 1) {
                    if (d.selected == 2) {
                        if (d.type > 0 && hit.type != d.type) {


                            if ((x == d.k && (y == d.t || z == d.e)) || (y == d.t && (x == d.k || z == d.e)) || (z == d.e && (y == d.t || x == d.k))) {

                                let dx = Math.abs(x - d.k);
                                let dy = Math.abs(y - d.t);
                                let dz = Math.abs(z - d.e);

                                if (d.subtype == 2) {
                            if ((dx + dy + dz) <= 3) {
                                glob = 1
    

                                    if (hit.type > 0) {
                                        let k1 = hit.k
                                        let t1 = hit.t
                                        let e1 = hit.e



                                        hit.type = 0
                                        hit.subtype = 0
                                        hit.selected = 0

                                        for (let dk = -1; dk <= 1; dk++) {
                                            for (let dt = -1; dt <= 1; dt++) {
                                                for (let de = -1; de <= 1; de++) {
                                                    let k = k1 + dk;
                                                    let t = t1 + dt;
                                                    let e = e1 + de;

                                                    // Check bounds to avoid errors
                                                    if (
                                                        k >= 0 && k < grid.grid.length &&
                                                        t >= 0 && t < grid.grid[k].length &&
                                                        e >= 0 && e < grid.grid[k][t].length
                                                    ) {
                                                        let node = grid.grid[k][t][e];
                                                        if (node.type != d.type) {
                                                            node.type = hit.type;
                                                            node.subtype = hit.subtype;
                                                            node.selected = hit.selected;

                                                            node.blasted = 25
                                                        }
                                                    }
                                                }
                                            }
                                        }



                                        hit.type = d.type
                                        hit.subtype = d.subtype
                                        hit.selected = 0
                                        d.type = 0
                                        d.subtype = 0
                                        d.selected = 0



                                    } else {

                                        hit.type = d.type
                                        hit.subtype = d.subtype
                                        d.type = 0
                                        d.subtype = 0
                                        d.selected = 0
                                        hit.selected = 0
                                    }


    
                                }else{
                                    
                                glob = 0
                                }
                                } else if (d.subtype == 3 && (hit.subtype > 0)) {
                                    console.log(hit)
                                } else if (d.subtype == 3) {
                                    let kd = d.k - hit.k
                                    let td = d.t - hit.t
                                    let ed = d.e - hit.e

                                    console.log(td)
                                    if (kd != 0) {
                                        for (let w = hit.k; w < d.k; w++) {
                                            if (grid.grid[w][d.t][d.e].type < 1) {
                                                grid.grid[w][d.t][d.e].type = Math.max(d.type, d.type)
                                                grid.grid[w][d.t][d.e].subtype = 1
                                            }
                                        }
                                        for (let w = d.k; w < hit.k; w++) {
                                            if (grid.grid[w][d.t][d.e].type < 1) {
                                                grid.grid[w][d.t][d.e].type = Math.max(d.type, d.type)
                                                grid.grid[w][d.t][d.e].subtype = 1
                                            }
                                        }
                                    } else if (td != 0) {
                                        for (let w = hit.t; w < d.t; w++) {
                                            if (grid.grid[d.k][w][d.e].type < 1) {
                                                grid.grid[d.k][w][d.e].type = Math.max(d.type, d.type)
                                                grid.grid[d.k][w][d.e].subtype = 1
                                            }
                                        }
                                        for (let w = d.t; w < hit.t; w++) {
                                            if (grid.grid[d.k][w][d.e].type < 1) {
                                                grid.grid[d.k][w][d.e].type = Math.max(d.type, d.type)
                                                grid.grid[d.k][w][d.e].subtype = 1
                                            }
                                        }
                                    } else if (ed != 0) {
                                        console.log(ed)
                                        for (let w = hit.e; w < d.e; w++) {
                                            if (grid.grid[d.k][d.t][w].type < 1) {
                                                grid.grid[d.k][d.t][w].type = Math.max(d.type, d.type)
                                                grid.grid[d.k][d.t][w].subtype = 1
                                            }
                                        }
                                        for (let w = d.e; w < hit.e; w++) {
                                            if (grid.grid[d.k][d.t][w].type < 1) {
                                                grid.grid[d.k][d.t][w].type = Math.max(d.type, d.type)
                                                grid.grid[d.k][d.t][w].subtype = 1
                                            }
                                        }
                                    }

                                    hit.type = d.type
                                    d.subtype = 1
                                    hit.subtype = 3
                                    hit.selected = 0


                                } else {

                                    if(d.subtype == 1){
                                        let dx = Math.abs(x - d.k);
                                let dy = Math.abs(y - d.t);
                                let dz = Math.abs(z - d.e);

                            if ((dx + dy + dz) <= 3) {
                                hit.type = d.type
                                    hit.subtype = d.subtype
                                    d.type = 0
                                    d.subtype = 0
                                    d.selected = 0
                                    hit.selected = 0

                            }
                                    }

                                }

                                if (d.subtype == 3 && (hit.subtype > 0)) {
                                    console.log('w')
                                    d.selected = 0
                                    hit.selected = 0
                                    



                                    if(hit.type != d.type && hit.type > 0){


}else{
grid.turn *= -1
let mes = grid.printSelf()
let data = {}
data.board = mes
data.tile = 1
console.log(data)
ws.send(JSON.stringify(data))
grid.apply(mes)
return

}


                                }else if(glob == 0){

                                d.selected = 0
                                hit.selected = 0
                                }  else  {

                                    grid.turn *= -1
                                    let mes = grid.printSelf()
                                    let data = {}
                                    data.board = mes
                                    data.tile = 1
                                    console.log(data)
                                    ws.send(JSON.stringify(data))
                                    grid.apply(mes)

                                }
                            }
                        }
                    }
                } else if (grid.turn == 1 && d.type == 2) {
                    if (d.selected == 2) {
                        if (d.type > 0 && hit.type != d.type) {

                            if ((x == d.k && (y == d.t || z == d.e)) || (y == d.t && (x == d.k || z == d.e)) || (z == d.e && (y == d.t || x == d.k))) {

                                let dx = Math.abs(x - d.k);
                                let dy = Math.abs(y - d.t);
                                let dz = Math.abs(z - d.e);

                                if (d.subtype == 2) {
                            if ((dx + dy + dz) <= 3) {
                                glob = 1


                                    if (hit.type > 0) {
                                        let k1 = hit.k
                                        let t1 = hit.t
                                        let e1 = hit.e



                                        hit.type = 0
                                        hit.subtype = 0
                                        hit.selected = 0

                                        for (let dk = -1; dk <= 1; dk++) {
                                            for (let dt = -1; dt <= 1; dt++) {
                                                for (let de = -1; de <= 1; de++) {
                                                    let k = k1 + dk;
                                                    let t = t1 + dt;
                                                    let e = e1 + de;

                                                    // Check bounds to avoid errors
                                                    if (
                                                        k >= 0 && k < grid.grid.length &&
                                                        t >= 0 && t < grid.grid[k].length &&
                                                        e >= 0 && e < grid.grid[k][t].length
                                                    ) {
                                                        let node = grid.grid[k][t][e];
                                                        if (node.type != d.type) {
                                                            node.type = hit.type;
                                                            node.subtype = hit.subtype;
                                                            node.selected = hit.selected;
                                                            node.blasted = 25
                                                        }
                                                    }
                                                }
                                            }
                                        }



                                        hit.type = d.type
                                        hit.subtype = d.subtype
                                        hit.selected = 0
                                        d.type = 0
                                        d.subtype = 0
                                        d.selected = 0



                                    } else {

                                        hit.type = d.type
                                        hit.subtype = d.subtype
                                        d.type = 0
                                        d.subtype = 0
                                        d.selected = 0
                                        hit.selected = 0

                                    }

                                }else{
                                    glob = 0
                                }

                                } else if (d.subtype == 3 && (hit.subtype > 0)) {

                                } else if (d.subtype == 3) {
                                    let kd = d.k - hit.k
                                    let td = d.t - hit.t
                                    let ed = d.e - hit.e

                                    console.log(td)
                                    if (kd != 0) {
                                        for (let w = hit.k; w < d.k; w++) {
                                            if (grid.grid[w][d.t][d.e].type < 1) {
                                                grid.grid[w][d.t][d.e].type = Math.max(d.type, d.type)
                                                grid.grid[w][d.t][d.e].subtype = 1
                                            }
                                        }
                                        for (let w = d.k; w < hit.k; w++) {
                                            if (grid.grid[w][d.t][d.e].type < 1) {
                                                grid.grid[w][d.t][d.e].type = Math.max(d.type, d.type)
                                                grid.grid[w][d.t][d.e].subtype = 1
                                            }
                                        }
                                    } else if (td != 0) {
                                        for (let w = hit.t; w < d.t; w++) {
                                            if (grid.grid[d.k][w][d.e].type < 1) {
                                                grid.grid[d.k][w][d.e].type = Math.max(d.type, d.type)
                                                grid.grid[d.k][w][d.e].subtype = 1
                                            }
                                        }
                                        for (let w = d.t; w < hit.t; w++) {
                                            if (grid.grid[d.k][w][d.e].type < 1) {
                                                grid.grid[d.k][w][d.e].type = Math.max(d.type, d.type)
                                                grid.grid[d.k][w][d.e].subtype = 1
                                            }
                                        }
                                    } else if (ed != 0) {
                                        console.log(ed)
                                        for (let w = hit.e; w < d.e; w++) {
                                            if (grid.grid[d.k][d.t][w].type < 1) {
                                                grid.grid[d.k][d.t][w].type = Math.max(d.type, d.type)
                                                grid.grid[d.k][d.t][w].subtype = 1
                                            }
                                        }
                                        for (let w = d.e; w < hit.e; w++) {
                                            if (grid.grid[d.k][d.t][w].type < 1) {
                                                grid.grid[d.k][d.t][w].type = Math.max(d.type, d.type)
                                                grid.grid[d.k][d.t][w].subtype = 1
                                            }
                                        }
                                    }

                                    hit.type = d.type
                                    d.subtype = 1
                                    hit.subtype = 3
                                    hit.selected = 0


                                } else {

                                    hit.type = d.type
                                    hit.subtype = d.subtype
                                    d.type = 0
                                    d.subtype = 0
                                    d.selected = 0
                                    hit.selected = 0

                                }


                                if (d.subtype == 3 && (hit.subtype > 0)) {
                        
                                    console.log('w')
                                    d.selected = 0
                                    hit.selected = 0

                                    // return

                                    if(hit.type != d.type && hit.type > 0){


                                    }else{
                                    grid.turn *= -1
                                    let mes = grid.printSelf()
                                    let data = {}
                                    data.board = mes
                                    data.tile = 1
                                    console.log(data)
                                    ws.send(JSON.stringify(data))
                                    grid.apply(mes)
                                    return

                                    }
                                }else if(glob == 0){

                                    d.selected = 0
                                    hit.selected = 0
                                }else {
                                    

                                    grid.turn *= -1
                                    let mes = grid.printSelf()
                                    let data = {}
                                    data.board = mes
                                    data.tile = 1
                                    console.log(data)
                                    ws.send(JSON.stringify(data))
                                    grid.apply(mes)

                                }


                            }
                        }
                    }
                }
            })


            hit.r = 1
            hit.g = 1
            hit.b = 1
        } else {
            selected = null;
        }
    });

    window.addEventListener("pointerup", e => {
        if (selected) {
            console.log("Released point:", selected);
            selected = null;
        }
    });




    document.addEventListener('keydown', (event) => {
        keysPressed[event.key] = true;
    });
    document.addEventListener('keyup', (event) => {
        delete keysPressed[event.key];
    });
    window.addEventListener('pointerdown', e => {
        FLEX_engine = canvas.getBoundingClientRect();
        XS_engine = e.clientX - FLEX_engine.left;
        YS_engine = e.clientY - FLEX_engine.top;
        TIP_engine.x = XS_engine
        TIP_engine.y = YS_engine
        TIP_engine.body = TIP_engine
        // example usage: if(object.isPointInside(TIP_engine)){ take action }
    });
    window.addEventListener('pointermove', continued_stimuli);
    window.addEventListener('pointerup', e => {
        // window.removeEventListener("pointermove", continued_stimuli);
    })

    function continued_stimuli(e) {
        FLEX_engine = canvas.getBoundingClientRect();
        XS_engine = e.clientX - FLEX_engine.left;
        YS_engine = e.clientY - FLEX_engine.top;
        TIP_engine.x = XS_engine
        TIP_engine.y = YS_engine
        TIP_engine.body = TIP_engine

        grid.hover(TIP_engine, 7); // 12px tolerance
    }
}

function gamepad_control(object, speed = 1) { // basic control for objects using the controler
    //         //console.l\og(gamepadAPI.axesStatus[1]*gamepadAPI.axesStatus[0]) //debugging
    if (typeof object.body != 'undefined') {
        if (typeof(gamepadAPI.axesStatus[1]) != 'undefined') {
            if (typeof(gamepadAPI.axesStatus[0]) != 'undefined') {
                object.body.x += (gamepadAPI.axesStatus[0] * speed)
                object.body.y += (gamepadAPI.axesStatus[1] * speed)
            }
        }
    } else if (typeof object != 'undefined') {
        if (typeof(gamepadAPI.axesStatus[1]) != 'undefined') {
            if (typeof(gamepadAPI.axesStatus[0]) != 'undefined') {
                object.x += (gamepadAPI.axesStatus[0] * speed)
                object.y += (gamepadAPI.axesStatus[1] * speed)
            }
        }
    }
}

function control(object, speed = 1) { // basic control for objects
    if (typeof object.body != 'undefined') {
        if (keysPressed['w']) {
            object.body.y -= speed
        }
        if (keysPressed['d']) {
            object.body.x += speed
        }
        if (keysPressed['s']) {
            object.body.y += speed
        }
        if (keysPressed['a']) {
            object.body.x -= speed
        }
    } else if (typeof object != 'undefined') {
        if (keysPressed['w']) {
            object.y -= speed
        }
        if (keysPressed['d']) {
            object.x += speed
        }
        if (keysPressed['s']) {
            object.y += speed
        }
        if (keysPressed['a']) {
            object.x -= speed
        }
    }
}

function getRandomLightColor() { // random color that will be visible on  black background
    var letters = '0123456789ABCDEF';
    var color = '#';
    for (var i = 0; i < 6; i++) {
        color += letters[(Math.floor(Math.random() * 12) + 4)];
    }
    return color;
}

function getRandomColor() { // random color
    var letters = '0123456789ABCDEF';
    var color = '#';
    for (var i = 0; i < 6; i++) {
        color += letters[(Math.floor(Math.random() * 16) + 0)];
    }
    return color;
}

function getRandomDarkColor() { // color that will be visible on a black background
    var letters = '0123456789ABCDEF';
    var color = '#';
    for (var i = 0; i < 6; i++) {
        color += letters[(Math.floor(Math.random() * 12))];
    }
    return color;
}

function castBetween(from, to, granularity = 10, radius = 1) { //creates a sort of beam hitbox between two points, with a granularity (number of members over distance), with a radius defined as well
    let limit = granularity
    let shape_array = []
    for (let t = 0; t < limit; t++) {
        let circ = new Circle((from.x * (t / limit)) + (to.x * ((limit - t) / limit)), (from.y * (t / limit)) + (to.y * ((limit - t) / limit)), radius, "red")
        circ.toRatio = t / limit
        circ.fromRatio = (limit - t) / limit
        shape_array.push(circ)
    }
    return (new Shape(shape_array))
}

function castBetweenPoints(from, to, granularity = 10, radius = 1) { //creates a sort of beam hitbox between two points, with a granularity (number of members over distance), with a radius defined as well
    let limit = granularity
    let shape_array = []
    for (let t = 0; t < limit; t++) {
        let circ = new Circle((from.x * (t / limit)) + (to.x * ((limit - t) / limit)), (from.y * (t / limit)) + (to.y * ((limit - t) / limit)), radius, "red")
        circ.toRatio = t / limit
        circ.fromRatio = (limit - t) / limit
        shape_array.push(circ)
    }
    return shape_array
}

class Disang {
    constructor(dis, ang) {
        this.dis = dis
        this.angle = ang
    }
}

class BezierHitbox {
    constructor(x, y, cx, cy, ex, ey, color = "red") { // this function takes a starting x,y, a control point x,y, and a end point x,y
        this.color = color
        this.x = x
        this.y = y
        this.cx = cx
        this.cy = cy
        this.ex = ex
        this.ey = ey
        this.metapoint = new Circle((x + cx + ex) / 3, (y + cy + ey) / 3, 3, "#FFFFFF")
        this.granularity = 100
        this.body = [...castBetweenPoints((new Point(this.x, this.y)), (new Point(this.ex, this.ey)), this.granularity, 0)]

        let angle = (new Line(this.x, this.y, this.ex, this.ey)).angle()

        this.angles = []
        for (let t = 0; t < this.granularity; t++) {
            this.angles.push(angle)
        }
        for (let t = 0; t <= 1; t += 1 / this.granularity) {
            this.body.push(this.getQuadraticXY(t))
            this.angles.push(this.getQuadraticAngle(t))
        }
        this.hitbox = []
        for (let t = 0; t < this.body.length; t++) {
            let link = new LineOP(this.body[t], this.metapoint)
            let disang = new Disang(link.hypotenuse(), link.angle() + (Math.PI * 2))
            this.hitbox.push(disang)
        }
        this.constructed = 1
    }
    isPointInside(point) {
        let link = new LineOP(point, this.metapoint)
        let angle = (link.angle() + (Math.PI * 2))
        let dis = link.hypotenuse()
        for (let t = 1; t < this.hitbox.length; t++) {
            if (Math.abs(this.hitbox[t].angle - this.hitbox[t - 1].angle) > 1) {
                continue
            }
            if (angle.between(this.hitbox[t].angle, this.hitbox[t - 1].angle)) {
                if (dis < (this.hitbox[t].dis + this.hitbox[t - 1].dis) * .5) {
                    return true
                }
            }
        }
        return false
    }
    doesPerimeterTouch(point) {
        let link = new LineOP(point, this.metapoint)
        let angle = (link.angle() + (Math.PI * 2))
        let dis = link.hypotenuse()
        for (let t = 1; t < this.hitbox.length; t++) {
            if (Math.abs(this.hitbox[t].angle - this.hitbox[t - 1].angle) > 1) {
                continue
            }
            if (angle.between(this.hitbox[t].angle, this.hitbox[t - 1].angle)) {
                if (dis < ((this.hitbox[t].dis + this.hitbox[t - 1].dis) * .5) + point.radius) {
                    return this.angles[t]
                }
            }
        }
        return false
    }
    draw() {
        this.metapoint.draw()
        let tline = new Line(this.x, this.y, this.ex, this.ey, this.color, 3)
        tline.draw()
        canvas_context.beginPath()
        this.median = new Point((this.x + this.ex) * .5, (this.y + this.ey) * .5)
        let angle = (new LineOP(this.median, this.metapoint)).angle()
        let dis = (new LineOP(this.median, this.metapoint)).hypotenuse()
        canvas_context.bezierCurveTo(this.x, this.y, this.cx - (Math.cos(angle) * dis * .38), this.cy - (Math.sin(angle) * dis * .38), this.ex, this.ey)

        canvas_context.fillStyle = this.color
        canvas_context.strokeStyle = this.color
        canvas_context.lineWidth = 3
        canvas_context.stroke()
    }
    getQuadraticXY(t) {
        return new Point((((1 - t) * (1 - t)) * this.x) + (2 * (1 - t) * t * this.cx) + (t * t * this.ex), (((1 - t) * (1 - t)) * this.y) + (2 * (1 - t) * t * this.cy) + (t * t * this.ey))
    }
    getQuadraticAngle(t) {
        var dx = 2 * (1 - t) * (this.cx - this.x) + 2 * t * (this.ex - this.cx);
        var dy = 2 * (1 - t) * (this.cy - this.y) + 2 * t * (this.ey - this.cy);
        return -Math.atan2(dx, dy) + 0.5 * Math.PI;
    }
}
Number.prototype.between = function(a, b, inclusive) {
    var min = Math.min(a, b),
        max = Math.max(a, b);
    return inclusive ? this >= min && this <= max : this > min && this < max;
}

let setup_canvas = document.getElementById('canvas') //getting canvas from document

setUp(setup_canvas) // setting up canvas refrences, starting timer. 

// object instantiation and creation happens here 
// class PolygonSorter {
//     constructor(points) {
//         this.points = points;
//         this.hull = this.computeConcavePolygon();
//     }

//     computeConcavePolygon() {
//         // Ensure we work on a copy of the points
//         const points = this.points.slice();

//         // Sort points by their position (you may want a specific order)
//         points.sort((a, b) => a.x - b.x || a.y - b.y);

//         // Start with the first point
//         const polygon = [points[0]];

//         // Iterate through the points to create a non-crossing concave shape
//         for (let i = 1; i < points.length; i++) {
//             const point = points[i];

//             // Check for intersection and add the point
//             while (polygon.length > 1 && this.doesIntersect(polygon[polygon.length - 2], polygon[polygon.length - 1], polygon[polygon.length - 1], point)) {
//                 polygon.pop(); // Remove last point if it causes intersection
//             }
//             polygon.push(point);
//         }

//         // Optionally, close the polygon by connecting back to the starting point
//         if (polygon.length > 2 && !this.doesIntersect(polygon[polygon.length - 1], polygon[0], polygon[polygon.length - 1], polygon[0])) {
//             polygon.push(polygon[0]); // Close the polygon if it doesn't cause an intersection
//         }

//         return polygon;
//     }

//     doesIntersect(p1, q1, p2, q2) {
//         // Helper function to check if two segments intersect
//         return this.orientation(p1, q1, p2) !== this.orientation(p1, q1, q2) &&
//                this.orientation(p2, q2, p1) !== this.orientation(p2, q2, q1);
//     }

//     orientation(p, q, r) {
//         const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
//         return val === 0 ? 0 : (val > 0 ? 1 : 2); // collinear, clockwise, counterclockwise
//     }

//     minimizeArea(polygon) {
//         // Implement a strategy to minimize the area of the polygon
//         // This can involve a more complex triangulation method if needed
//         return polygon; // Placeholder: Return the input polygon for now
//     }

//     getSortedPoints() {
//         return this.minimizeArea(this.hull);
//     }
// }
class PolygonSorter {
    constructor(points) {
        this.points = points;
        this.hull = this.points
    }

    // Function to calculate the centroid of the points
    calculateCentroid() {
        const numPoints = this.points.length;
        const sum = this.points.reduce((acc, point) => {
            acc.x += point.x;
            acc.y += point.y;
            return acc;
        }, {
            x: 0,
            y: 0
        });

        return {
            x: sum.x / numPoints,
            y: sum.y / numPoints
        };
    }

    // Function to calculate the angle between the point and the centroid
    calculateAngle(point, centroid) {
        return Math.atan2(point.y - centroid.y, point.x - centroid.x);
    }

    // Function to sort points based on their angle relative to the centroid
    sortPointsByAngle() {
        const centroid = this.calculateCentroid();
        this.points.sort((a, b) => {
            const angleA = this.calculateAngle(a, centroid);
            const angleB = this.calculateAngle(b, centroid);
            return angleA - angleB; // Sort by angle in ascending order
        });
        return this.points; // Return the sorted array
    }
}



class PolygonDrawer {
    constructor(points, color = '#000000', width = 3) {
        this.points = points; // Array of Point objects
        //console.l\og(points)
        this.color = color;
        this.width = width;
        this.hull = this.points
    }


    // Function to calculate the centroid of the points
    calculateCentroid() {
        const numPoints = this.points.length;
        const sum = this.points.reduce((acc, point) => {
            acc.x += point.x;
            acc.y += point.y;
            return acc;
        }, {
            x: 0,
            y: 0
        });

        return {
            x: sum.x / numPoints,
            y: sum.y / numPoints
        };
    }

    // Function to calculate the angle between the point and the centroid
    calculateAngle(point, centroid) {
        return Math.atan2(point.y - centroid.y, point.x - centroid.x);
    }

    // Function to sort points based on their angle relative to the centroid
    sortPointsByAngle() {
        const centroid = this.calculateCentroid();
        this.points.sort((a, b) => {
            const angleA = this.calculateAngle(a, centroid);
            const angleB = this.calculateAngle(b, centroid);
            return angleA - angleB; // Sort by angle in ascending order
        });
        return this.points; // Return the sorted array
    }
    drawHull() {
        if (this.liner != 1) {

            this.links = []
            for (let i = 0; i < this.hull.length; i++) {
                const start = this.hull[i];
                const end = this.hull[(i + 1) % this.hull.length]; // Wrap around to the first point
                const lineOp = new LineOP(start, end, this.color, this.width);
                lineOp.draw();
                this.links.push(lineOp)
            }
        }
        this.liner = 1

        this.sums = [0, 0, 0, 0]
        let f = 0

        for (let t = 0; t < people.length; t++) {
            if (isPointInPolygon(this.hull, people[t].body)) {
                this.sums[people[t].type]++
                f++
            }
        }

        // Determine the color based on which sum is maximum
        let calccolor;
        //console.l\og(this.sums)
        const maxSum = Math.max(...this.sums);
        const maxIndex = this.sums.indexOf(maxSum);

        if (f != groups[groupi]) {
            calccolor = '#88888888'
            this.t = -1
        } else {

            if (maxIndex === 0) {
                calccolor = '#ff000040';
                this.t = 0
            } else if (maxIndex === 1) {
                this.t = 1
                calccolor = '#00ff0040';
            } else if (maxIndex === 2) {
                this.t = 2
                calccolor = '#0000ff40';
            } else if (maxIndex === 3) {
                this.t = 3
                calccolor = '#ffff0040';
            } else {
                this.t = -1
                calccolor = 'white'; // Replace with a color for index 2 and 3 if needed
            }

        }

        const maxCount = this.sums.filter(sum => sum === maxSum).length;

        if (maxCount > 1) {
            calccolor = '#88888888'; // Set to gray if there are ties
        }


        fillPolygon(canvas_context, this.hull, calccolor)
    }
}

function fillPolygon(ctx, points, color) {
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);

    for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
    }

    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
}

class People {
    constructor(x, y, colorValue) {
        this.type = colorValue
        this.body = new Circle(x, y, 50, "white");
        this.colors = ['red', '#00ff00', 'blue', 'yellow'];

        this.body.color = this.colors[colorValue % 4];
    }

    // Check if the circle is on the line
    isCircleOnLine(link) {
        this.body.radius = 50
        const x = this.body.x;
        const y = this.body.y;
        const radius = this.body.radius;

        // Line is defined by two points (x1, y1) and (x2, y2)
        // const [x1, y1, x2, y2] = link;
        const x1 = link.object.x
        const x2 = link.target.x
        const y1 = link.object.y
        const y2 = link.target.y

        // Line equation: Ax + By + C = 0
        const A = y2 - y1;
        const B = x1 - x2;
        const C = x2 * y1 - x1 * y2;

        // Distance from circle center to the line
        const distance = Math.abs(A * x + B * y + C) / Math.sqrt(A * A + B * B);

        // Check if the distance is less than or equal to the radius
        return distance <= radius;
    }
    draw() {
        this.body.radius = 10
        this.body.draw()
    }
}
let hulls = []
let hull = []
let people = []
let peo = []

let groups = [3, 4, 5, 6, 10, 12]

let diff = 2
let groupi = 3
for (let t = 0; t < 60; t++) {
    peo.push(t % diff)
}

for (let t = 0; t < 60; t++) {
    let per = new People(100 + (100 * (t % 10)), 100 + (100 * Math.floor(t / 10)), peo[t])

    people.push(per)
}


function isPointInPolygon(point, polygon) {
    const {
        x,
        y
    } = point;
    let isInside = false;

    // Loop through each edge of the polygon
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const {
            x: xi,
            y: yi
        } = polygon[i];
        const {
            x: xj,
            y: yj
        } = polygon[j];

        // Check if the point is inside the polygon
        const intersect = ((yi > y) !== (yj > y)) &&
            (x < (xj - xi) * (y - yi) / (yj - yi) + xi);

        if (intersect) {
            isInside = !isInside;
        }
    }

    return isInside;
}

let h1 = {}
let sure = {}

function isPointInPolygon(points, testPoint) {
    const x = testPoint.x;
    const y = testPoint.y;
    let inside = false;

    for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
        const xi = points[i].x;
        const yi = points[i].y;
        const xj = points[j].x;
        const yj = points[j].y;

        const intersect = ((yi > y) !== (yj > y)) &&
            (x < (xj - xi) * (y - yi) / (yj - yi) + xi);

        if (intersect) {
            inside = !inside;
        }
    }

    return inside;
}

function arePointsOverlapping(a, b, c, d, e, f, g, h) {
    // Create an array of points from the provided coordinates
    const points = [{
            x: a,
            y: b
        }, // First point
        {
            x: c,
            y: d
        }, // Second point
        {
            x: e,
            y: f
        }, // Third point
        {
            x: g,
            y: h
        } // Fourth point
    ];

    console.log(points)
    // Use a Set to track unique positions
    const uniquePositions = new Set();

    for (const point of points) {
        // Create a unique key for each point based on its x and y values
        const key = `${point.x},${point.y}`;

        // If the key is already in the Set, return true (overlapping point found)
        if (uniquePositions.has(key)) {
            return true;
        }

        // Add the key to the Set
        uniquePositions.add(key);
    }

    // No overlapping points found
    return false;
}
// returns true if the line from (a,b)->(c,d) intersects with (p,q)->(r,s)
function intersects(a, b, c, d, p, q, r, s) {
    var det, gamma, lambda;
    a = Math.round(a)
    b = Math.round(b)
    c = Math.round(c)
    d = Math.round(d)
    p = Math.round(p)
    q = Math.round(q)
    r = Math.round(r)
    s = Math.round(s)
    console.log(arePointsOverlapping(a, b, c, d, p, q, r, s))
    if (arePointsOverlapping(a, b, c, d, p, q, r, s)) {
        return false
    }


    det = (c - a) * (s - q) - (r - p) * (d - b);
    if (det === 0) {
        return false;
    } else {
        lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
        gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
        return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
    }
};




// Example usage
// const polygon1 = [{x: 1, y: 1}, {x: 3, y: 3}, {x: 1, y: 3}, {x: 3, y: 1}]; // Self-intersecting
// const polygon2 = [{x: 1, y: 1}, {x: 1, y: 5}, {x: 5, y: 5}, {x: 5, y: 1}]; // Not self-intersecting

// //console.l\og(isPolygonSelfIntersecting(polygon1)); // true
// //console.l\og(isPolygonSelfIntersecting(polygon2)); // false




class Puppeteer {
    constructor(points, personSpawnID, targetRoom, footing, targetID) {
        this.points = points //points is a list of x,y objects like {"x":10,"y":12}, they will be in an array like [point1, point2, point3] etc.
        this.targetRoom = targetRoom //Target room is where the new character will spawn
        this.personSpawnID = personSpawnID //this is the ID of who will spawn in the room (at the footing)
        this.footing = footing //this is an  x,y object, just one, not a list, like point =  {"x":10,"y":12}, and it's where the npc will spawn
        this.targetID = targetID //this is the ID of who will be moved in the room to a new position, and will tag their people object to animate a walk animation(which exist)


        //animation variables, these control the puppeting 
        this.count = 0 //what "frame" of the interpolation between the points selected
        this.pointer1 = 0; //this is the starting point in the array for where to interopolate from
        this.ponter2 = 1 // this is the number that is the index of the point to interpolate to 
        this.distances = [] //arraay this holds the distances in pixels from A to B as they traverse
        this.lengths = [] //the lengths in frames of how long they will be walking from a to b
        this.link = new LineOP(this.points[0].this.points[1]) //dummy line object for geometry
        for (let t = 1; t < this.points.length; t++) { //loop for calculating the distances and lengths
            this.link.target = this.points[t] //this sets the line geometry to measure from the point at index t
            this.link.object = this.points[t - 1] //this sets the line geometry to measure to the point at index t-1,,this with the array starting loop at 1 means it won't overflow, regardless of the points, as long as there are two or more
            let h = this.link.hypotenuse() //h is the hypotenuse of the line that connects the points in question, and makes for a measure of their euclidian distance
            this.distances.push(h) //then we store that distance
            this.lengths.push(Math.ceil(h / 6)) //and also store the length in frames they will be animated for
        }



        this.active = 1 // sets up to run automatically on formation of trigger

    }
    interpolate(point1, point2, time, length) {
        let x = point1.x + ((point2.x - point1.x) * (time / length)) //averaging from x to x on a time slider
        let y = point1.y + ((point2.y - point1.y) * (time / length)) //averaging from y to y on a time slider
        return {
            "x": x,
            "y": y
        }
    }
    play() { //this will be on all triggerd puppet objects, in a loop of their array, in main probably at the top, and there will need to be a cleanup function
        if (this.active == 1) {

            //lookup people data and convert them to a class variable called target person
            this.targetPerson = {} //lookup

            let interpoint = this.interpolate(this.points[this.pointer1], this.points[this.ponter2], this.count, this.lengths[this.ponter2]) //call for the creation of a point that is where the npc should be drawn
            this.targetPerson.x = interpoint.x
            this.targetPerson.y = interpoint.y


            this.count++
            if (this.count > this.lengths[this.ponter2]) {
                this.count = 0
                this.pointer1++ //increment to the next point
                this.pointer2++ //increment to the next point
                if (this.pointer2 > this.lengths.length) { //if it's the ned, tun the swap

                    this.targetPerson.kill = 1 //code to remove target person from the array of people

                    let newDude = new Person(this.personSpawnID, this.footing.x, this.footing.y) //code to add people to other room 
                    people[this.targetRoom].push(newDude)
                    this.cleanup()
                }
            }
        }

    }
    cleanup() {
        this.active = 0
    }

}


let cs = []

// for (let t = 1; t < 30; t++) {
//     const ing = new Image()
//     ing.src = `guy${t}.png`
//     cs.push(ing)
// }
const angles = [
    -2.356194490192345, // top-left (0,0)
    -1.5707963267948966, // top-middle (0,1)
    -0.7853981633974483, // top-right (0,2)
    3.141592653589793, // middle-left (1,0)
    0.0, // middle- (0,0)
    0.0, // middle-right (1,2)
    2.356194490192345, // bottom-left (2,0)
    1.5707963267948966, // bottom-middle (2,1)
    0.7853981633974483 // bottom-right (2,2)
];

let rotater = [0, 1, 2, 3, 4, 5, 6, 7, 8]
class Guy {
    constructor(type) {
        this.type = type
        this.frame = 0
        this.pushout = [0, 0, 0, 0, 0, 0, 0, 0, 0]

        this.happiness = 255
        if (this.type == 0) {
            this.pushout = [1, 1, 1, 1, 1, 1, 1, 1, 1]
            this.pushout[5] = -2.5
        }
        if (this.type == 1) {
            this.pushout = [0, 0, 0, 0, 0, 0, 0, 0, 0]
            this.pushout[4] = 5
        }
        if (this.type == 2) {
            this.pushout = [1, 2, 1, 0, 0, 0, 0 - 1, -2, -1]
        }
        if (this.type == 3) {
            this.pushout = [2, 4, 2, -1, -1, -1, -1 - 1, -2, -1]
        }
        if (this.type == 4) {
            this.pushout = [0, 0, 0, -1, 0, 0, 1, 1, 1]
        }
        if (this.type == 5) {
            this.pushout = [1, 2, 1, -5, 1, -5, 0, 0, 0]
        }
        if (this.type == 6) {
            this.pushout = [-1, -2, -1, 1, 2, 1, 0, 0, 0]
        }
        if (this.type == 7) {
            this.pushout = [0, 0, 0, 0, .5, 0, 0, 0, 0]
        }
        if (this.type == 8) {
            this.pushout = [0, 0, 0, 4, .5, -4, 0, 0, 0]
        }
        if (this.type == 9) {
            this.pushout = [-1, -1, -1, -1, -1, -1, -1, -1, -1]
        }
        if (this.type == 10) {
            this.pushout = [1, 0, 1, 0, 1, 0, 1, 0, 1]
        }
        if (this.type == 11) {
            this.pushout = [0, 1, 0, 1, 0, 1, 0, 1, 0]
        }
        if (this.type == 12) {
            this.pushout = [1, 2, 3, -3, 2, -1, 3, -2, 1]
        }
        if (this.type == 13) {
            this.pushout = [-.5, -.5, -.5, -.5, 5, -.5, -.5, -.5, -.5]
        }
        if (this.type == 14) {
            this.pushout = [.5, .5, .5, .5, -1.5, .5, .5, .5, .5]
        }
        if (this.type == 15) {
            this.pushout = [.5, .5, .5, .5, -1.5, .5, .5, .5, .5]
        }
        if (this.type == 16) {
            this.pushout = [1, 1, 1, 1, 1, 1, 1, 1, 1]
            this.pushout[3] = -2.5
        }
        if (this.type == 17) {
            this.pushout = [1, -1, 0, 1, 0, 1, 0, -1, 1]
        }
        if (this.type == 18) {
            this.pushout = [-1, 1, 1, 1, 0, 1, 1, 1, -1]
        }
        if (this.type == 19) {
            this.pushout = [-1, 1, -1, 2, 0, 1, 2, 1, -1]
        }
        if (this.type == 20) {
            this.pushout = [0, 0, 0, 1, 1, 1, 0, -3, 1]
        }
        if (this.type == 21) {
            this.pushout = [-1, 0, 2, 0, 0, 0, 2, 0, -1]
        }
        if (this.type == 22) {
            this.pushout = [-1, 2, -1, 1, 0, 1, -1, 2, -1]
        }
        if (this.type == 23) {
            this.pushout = [-1, 2, -1, 0, 2, 0, -1, 2, -1]
        }
        if (this.type == 24) {
            this.pushout = [0, 1, 2, 2, 1, 0, 1, 2, 0]
        }
        if (this.type == 25) {
            this.pushout = [1, 1, 2, -2, 1, -2, 1, 1, 2]
        }
        if (this.type == 26) {
            this.pushout = [-1, 2, -1, 2, -1, 2, -1, 2, -1]
        }
        if (this.type == 27) {
            this.pushout = [1, -2, 1, 2, 1, -2, 1, 2, 1]
        }
        if (this.type == 28) {
            this.pushout = [1, 1, 1, 0, -1, 0, -1, 0, 1]
        }
        if (this.type == 29) {
            this.pushout = [1, 1, 1, 1, 1, 1, 1, 1, 1]
        }
        if (this.type == 30) {
            this.pushout = [-1, 1, 2, 1, 0, 1, 2, 1, -1]
        }




    }

    draw(x, y) {
        this.frame++
        canvas_context.drawImage(cs[this.type], this.frame % Math.floor(cs[this.type].width / cs[this.type].height) * cs[this.type].height, 0, cs[this.type].height, cs[this.type].height, x, y, scale, scale)
        // let dot = new Circle(x,y, 3, "Red")
        // dot.draw()

        this.x = x
        this.y = y

    }
    links() {

        if (this.flagshow == 1) {

            let po = new Circle(this.x + 16, this.y + 16, 1, "red")

            for (let t = 0; t < this.pushout.length; t++) {
                if (this.pushout[t] != 0 && t != 4) {
                    let xi = (Math.cos((angles[t])) * 48) + this.x + 16
                    let yi = (Math.sin((angles[t])) * 48) + this.y + 16
                    let link = new LineOP(po, new Point(xi, yi), "black", 2)
                    link.color = ((Math.sign(this.pushout[t])) == 1 ? "#00ff00" : "#FF0000")
                    link.width = ((this.pushout[t] * .85) * (this.pushout[t] * .85) + 3)
                    link.draw()
                    let d = new Circle(xi, yi, link.width / 1.8, link.color)
                    d.draw()
                }
                if (this.pushout[t] != 0 && t == 4) {

                    let d = new Circle(this.x + 16, this.y + 16, this.pushout[t], ((Math.sign(this.pushout[t])) == 1 ? "#00ff00" : "#FF0000"))
                    d.draw()
                }
            }
        }

    }
    hover(poi) {
        // console.log(poi)
        let po = new Circle(this.x + 16, this.y + 16, 1, "red")

        let l = new LineOP(po, poi)

        if (l.hypotenuse() < 32) {
            this.flagshow = 1

        } else {
            this.flagshow = 0
        }
    }
}

let scale = 32
let scale2 = 48

class Brick {
    constructor(t, k) {
        this.t = t
        this.k = k

        this.health = 100
        this.guy = {}
        this.guy.type = -1
    }
    draw() {
        if (this.guy.type != -1) {
            let st = `rgb(${255-((this.guy.happiness-255)*2)},${this.guy.happiness},${128})`
            let rect = new Rectangle(this.t * scale2 + 150, this.k * scale2 + 150, scale2, scale2, `rgb(${255-((255-this.guy.happiness)*2)},${this.guy.happiness},${128})`)
            canvas_context.strokeStyle = st
            let sr = (scale2 - scale) / 4
            canvas_context.lineWidth = sr
            canvas_context.strokeRect(rect.x + sr, rect.y + sr, rect.width - sr, rect.height - sr)
            this.rect = rect
            this.guy.draw(rect.x + (sr * 2), rect.y + (sr * 2))
            // console.log(this.guy.type,rect.x+sr, rect.y+sr)


            let pairs = []
            for (let m = 0; m < pomansion.grid.length; m++) {
                for (let w = 0; w < pomansion.grid[m].length; w++) {
                    if (Math.abs(pomansion.grid[m][w].t - this.t) <= 1 && Math.abs(pomansion.grid[m][w].k - this.k) <= 1) {
                        pairs.push(pomansion.grid[m][w])
                    }
                }
            }

            for (let t = 0; t < pairs.length; t++) {
                pairs[t].guy.happiness += (this.guy.pushout[t]) / speed
            }


        } else {
            let st = `rgb(${128},${128},${128})`
            let rect = new Rectangle(this.t * scale2 + 150, this.k * scale2 + 150, scale2, scale2, `rgb(${255-((255-this.guy.happiness)*2)},${this.guy.happiness},${128})`)
            let sr = (scale2 - scale) / 4
            canvas_context.lineWidth = sr
            canvas_context.strokeStyle = st

            canvas_context.strokeRect(rect.x + sr, rect.y + sr, rect.width - sr, rect.height - sr)
            this.rect = rect
            // this.guy.draw(rect.x+sr, rect.y+sr)
        }
    }
    draw2() {
        if (this.guy.type != -1) {
            let st = `rgb(${255-((this.guy.happiness-255)*2)},${this.guy.happiness},${128})`
            let rect = new Rectangle(this.t * scale2 + 150, this.k * scale2 + 150, scale2, scale2, `rgb(${255-((255-this.guy.happiness)*2)},${this.guy.happiness},${128})`)
            canvas_context.strokeStyle = st
            let sr = (scale2 - scale) / 4
            canvas_context.lineWidth = sr
            // canvas_context.strokeRect(rect.x+sr, rect.y+sr, rect.width-sr, rect.height-sr)
            this.rect = rect
            this.guy.links(rect.x + (sr * 2), rect.y + (sr * 2))
            // console.log(this.guy.type,rect.x+sr, rect.y+sr)


            let pairs = []
            for (let m = 0; m < pomansion.grid.length; m++) {
                for (let w = 0; w < pomansion.grid[m].length; w++) {
                    if (Math.abs(pomansion.grid[m][w].t - this.t) <= 1 && Math.abs(pomansion.grid[m][w].k - this.k) <= 1) {
                        pairs.push(pomansion.grid[m][w])
                    }
                }
            }

            for (let t = 0; t < pairs.length; t++) {
                pairs[t].guy.happiness += this.guy.pushout[rotater[t]]
            }


        } else {
            let st = `rgb(${128},${128},${128})`
            let rect = new Rectangle(this.t * scale2 + 150, this.k * scale2 + 150, scale2, scale2, `rgb(${255-((255-this.guy.happiness)*2)},${this.guy.happiness},${128})`)
            let sr = (scale2 - scale) / 4
            canvas_context.lineWidth = sr
            canvas_context.strokeStyle = st

            // canvas_context.strokeRect(rect.x+sr, rect.y+sr, rect.width-sr, rect.height-sr)
            this.rect = rect
            // this.guy.draw(rect.x+sr, rect.y+sr)
        }
    }
}


class Mansion {
    constructor() {
        this.waitingguy = new Guy(Math.floor(Math.random() * cs.length))
        this.grid = []
        for (let t = 0; t < 8; t++) {
            this.grid.push([])
            for (let k = 0; k < 8; k++) {
                let brick = new Brick(k, t)

                this.grid[t].push(brick)
            }
        }

    }
    draw() {

        for (let t = 0; t < this.grid.length; t++) {
            for (let k = 0; k < this.grid[t].length; k++) {
                this.grid[t][k].draw()



            }
        }
        for (let t = 0; t < this.grid.length; t++) {
            for (let k = 0; k < this.grid[t].length; k++) {
                this.grid[t][k].draw2()



            }
        }


        this.waitingguy.draw(64, 64)
        this.waitingguy.links(64, 64)
        this.waitingguy.hover(TIP_engine)
    }
    check(poi) {
        for (let t = 0; t < this.grid.length; t++) {
            for (let k = 0; k < this.grid[t].length; k++) {


                if (this.grid[t][k].rect.isPointInside(poi) && keysPressed[' ']) {
                    this.grid[t][k].guy = this.waitingguy
                    this.waitingguy = new Guy(Math.floor(Math.random() * cs.length))
                } else if (this.grid[t][k].rect.isPointInside(poi)) {


                    let mr = 0
                    for (let m = 0; m < pomansion.grid.length; m++) {
                        for (let w = 0; w < pomansion.grid[m].length; w++) {

                            if (pomansion.grid[m][w].marked == 1) {

                                mr = 1
                                let sub = pomansion.grid[m][w].guy
                                let sub2 = this.grid[t][k].guy
                                this.grid[t][k].guy = sub
                                pomansion.grid[m][w].guy = sub2
                                pomansion.grid[m][w].marked = 0
                            }
                        }
                    }
                    if (mr == 0) {

                        this.grid[t][k].marked = 1
                    }

                }
            }
        }

    }
    hovercheck(poi) {
        for (let t = 0; t < this.grid.length; t++) {
            for (let k = 0; k < this.grid[t].length; k++) {


                // if(this.grid[t][k].rect.isPointInside(poi)){
                if (this.grid[t][k].guy.type != -1) {

                    this.grid[t][k].guy.hover(poi)
                }
                // }
            }
        }

    }
}



let gsize = 16
let thump = 5
let speed = 100

class Node4D {
    constructor(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        this.data = {}; // arbitrary storage
        this.grid = null; // set when added to a Grid4D
        this.type = -1
        this.subtype = -1
        this.stype = -1
        //   if(Math.random() < .01){
        //     this.stype = Math.floor(Math.random()*3)
        //   }
        if (x == 0 && y == 0 && z == 0 && w == 0) {
            this.type = 0
        }
        if (x == gsize - 1 && y == 0 && z == 0 && w == 0) {
            this.type = 1
        }
        if (x == 0 && y == gsize - 1 && z == 0 && w == 0) {
            this.type = 2
        }
        if (thump >= 4) {

            if (x == 0 && y == 0 && z == gsize - 1 && w == 0) {
                this.type = 3
            }
            if (thump >= 5) {

                if (x == 0 && y == 0 && z == 0 && w == gsize - 1) {
                    this.type = 4
                }
            }
        }
    }

    draw() {
        this.body = new Rectangle((this.x * 2) + (this.w * gsize * 2), (this.y * 2) + (this.z * gsize * 2), 2, 2, 'white')
        if (thump == 3) {
            if (this.type == 0) {
                this.body.color = 'RED'
            }
            if (this.type == 1) {
                this.body.color = '#00ff00'
            }
            if (this.type == 2) {
                this.body.color = 'blue'
            }

        }
        if (thump == 4) {
            if (this.type == 0) {
                this.body.color = 'RED'
            }
            if (this.type == 1) {
                this.body.color = '#FF8800'
            }
            if (this.type == 2) {
                this.body.color = '#FFFF00'
            }
            if (this.type == 3) {
                this.body.color = '#AAFF00'
            }

        }
        if (thump == 5) {
            if (this.type == 0) {
                this.body.color = '#0000ff'
            }
            if (this.type == 1) {
                this.body.color = '#8800ff'
            }
            if (this.type == 2) {
                this.body.color = '#ff00ff'
            }
            if (this.type == 3) {
                this.body.color = '#ff00aa'
            }
            if (this.type == 4) {
                this.body.color = '#ff0066'
            }

        }
        this.body.draw()
    }

    neighbors() {
        if (!this.grid) throw new Error("Node not assigned to a grid.");

        const deltas = [
            [1, 0, 0, 0],
            [-1, 0, 0, 0],
            [0, 1, 0, 0],
            [0, -1, 0, 0],
            [0, 0, 1, 0],
            [0, 0, -1, 0],
            [0, 0, 0, 1],
            [0, 0, 0, -1],
        ];

        const result = [];
        for (const [dx, dy, dz, dw] of deltas) {
            const neighbor = this.grid.getNode(this.x + dx, this.y + dy, this.z + dz, this.w + dw);
            if (neighbor) result.push(neighbor);
        }
        return result;
    }
}

class Grid4D {
    constructor(xSize, ySize, zSize, wSize) {
        this.xSize = xSize;
        this.ySize = ySize;
        this.zSize = zSize;
        this.wSize = wSize;

        // Build the grid of persistent Node objects
        this.nodes = [];
        for (let x = 0; x < xSize; x++) {
            this.nodes[x] = [];
            for (let y = 0; y < ySize; y++) {
                this.nodes[x][y] = [];
                for (let z = 0; z < zSize; z++) {
                    this.nodes[x][y][z] = [];
                    for (let w = 0; w < wSize; w++) {
                        const node = new Node4D(x, y, z, w);
                        node.grid = this;
                        this.nodes[x][y][z][w] = node;
                    }
                }
            }
        }
    }

    // Return a node at given coordinates, or null if out of bounds
    getNode(x, y, z, w) {
        if (
            x >= 0 && x < this.xSize &&
            y >= 0 && y < this.ySize &&
            z >= 0 && z < this.zSize &&
            w >= 0 && w < this.wSize
        ) {
            return this.nodes[x][y][z][w];
        }
        return null;
    }
    run() {

        for (let t = 0; t < this.xSize; t++) {
            for (let k = 0; k < this.ySize; k++) {
                for (let r = 0; r < this.zSize; r++) {
                    for (let w = 0; w < this.wSize; w++) {
                        let n = this.getNode(t, k, r, w)
                        let ne = n.neighbors()
                        for (let d = 0; d < ne.length; d++) {
                            if (ne[d].type == -1 && n.type != -1) {
                                ne[d].stype = n.type
                            }
                            if (thump == 3) {


                                if (ne[d].type == 0 && n.type == 1) {
                                    ne[d].stype = n.type
                                }
                                if (ne[d].type == 1 && n.type == 2) {
                                    ne[d].stype = n.type
                                }
                                if (ne[d].type == 2 && n.type == 0) {
                                    ne[d].stype = n.type
                                }
                            }
                            if (thump == 4) {


                                if (ne[d].type == 0 && (n.type == 1)) {
                                    ne[d].stype = n.type
                                }
                                if (ne[d].type == 1 && (n.type == 2)) {
                                    ne[d].stype = n.type
                                }

                                if (ne[d].type == 2 && (n.type == 3)) {
                                    ne[d].stype = n.type
                                }
                                if (ne[d].type == 3 && (n.type == 0)) {
                                    ne[d].stype = n.type
                                }
                            }
                            if (thump == 5) {


                                if (ne[d].type == 0 && (n.type == 1 || n.type == 2)) {
                                    ne[d].stype = n.type
                                }
                                if (ne[d].type == 1 && (n.type == 2 || n.type == 3)) {
                                    ne[d].stype = n.type
                                }

                                if (ne[d].type == 2 && (n.type == 3 || n.type == 4)) {
                                    ne[d].stype = n.type
                                }
                                if (ne[d].type == 3 && (n.type == 4 || n.type == 0)) {
                                    ne[d].stype = n.type
                                }
                                if (ne[d].type == 4 && (n.type == 0 || n.type == 1)) {
                                    ne[d].stype = n.type
                                }
                            }
                        }

                    }
                }
            }
        }


        for (let t = 0; t < this.xSize; t++) {
            for (let k = 0; k < this.ySize; k++) {
                for (let r = 0; r < this.zSize; r++) {
                    for (let w = 0; w < this.wSize; w++) {
                        let n = this.getNode(t, k, r, w)
                        n.type = n.stype
                        n.draw()
                    }
                }
            }
        }

    }
}


let g = new Grid4D(gsize, gsize, gsize, gsize)



class Flex3DObject {
    constructor(size = 6) {
        this.size = size;
        this.dots = [];
        this.links = [];
        this.center = {
            x: 0,
            y: 0,
            z: 0
        };

        this.turn = -1
        this.grid = []
        const step = (0.6 / this.size) * 6;
        const cstep = (35 / this.size) * 6;
        const half = Math.floor(size * 0.5);

        for (let k = -half; k < half; k++) {
            this.grid[k + half] = []
            for (let t = -half; t < half; t++) {
                this.grid[k + half][t + half] = []
                for (let e = -half; e < half; e++) {
                    let point = {
                        x: (k + 0.5) * step + (Math.random()/10000),
                        y: (t + 0.5) * step + (Math.random()/10000),
                        z: (e + 0.5) * step + (Math.random()/10000),
                        r: 128 + (e * cstep),
                        g: 128 + (t * cstep),
                        b: 128 + (k * cstep),
                        k: k + half,
                        t: t + half,
                        e: e + half,
                    };
                    point.blasted = -1
                    point.type = -1
                    point.subtype = -1
                    if (k < 0 && t < 0 && e < 0) {
                        point.type = 1
                        point.subtype = 1
                        if (k < -1 && t < -1 && e < -1) {
                            point.type = 1
                            point.subtype = 2
                            if (k < -2 && t < -2 && e < -2) {
                                point.type = 1
                                point.subtype = 3
                            }
                        }
                    }
                    if (k > -1 && t > -1 && e > -1) {
                        point.type = 2
                        point.subtype = 1
                        if (k > 0 && t > 0 && e > 0) {
                            point.type = 2
                            point.subtype = 2
                            if (k > 1 && t > 1 && e > 1) {
                                point.type = 2
                                point.subtype = 3
                            }
                        }
                    }
                    point.color = `rgb(${point.r}, ${point.g}, ${point.b})`
                    this.dots.push(point);
                    this.grid[k + half][t + half][e + half] = point
                }
            }
        }

        for (let t = 0; t < this.dots.length; t++) {

            console.log(this.dots[t].color)
            for (let d = -1; d < 1; d++) {
                for (let w = -1; w < 1; w++) {
                    for (let u = -1; u < 1; u++) {
                        if (((d == 0 && u == 0) || (w == 0 && u == 0) || (w == 0 && d == 0)) && !((w == 0 && d == 0 && u == 0))) {
                            this.links.push(new LineOP(this.dots[t], this.grid[Math.min(Math.max((this.dots[t].k + d), 0), this.size)][Math.min(Math.max((this.dots[t].t + w), 0), this.size)][Math.min(Math.max((this.dots[t].e + u), 0), this.size)], this.dots[t].color, 1));
                        }
                    }
                }
            }
        }


        console.log(this.grid)
    }

    rotateX(angle) {
        for (let d of this.dots) {
            let y = d.y,
                z = d.z;
            d.y = y * Math.cos(angle) - z * Math.sin(angle);
            d.z = y * Math.sin(angle) + z * Math.cos(angle);
        }
    }

    rotateY(angle) {
        for (let d of this.dots) {
            let x = d.x,
                z = d.z;
            d.x = x * Math.cos(angle) - z * Math.sin(angle);
            d.z = x * Math.sin(angle) + z * Math.cos(angle);
        }
    }

    rotateZ(angle) {
        for (let d of this.dots) {
            let x = d.x,
                y = d.y;
            d.x = x * Math.cos(angle) - y * Math.sin(angle);
            d.y = x * Math.sin(angle) + y * Math.cos(angle);
        }
    }

    project(orth = false, scale = 120, offset = 350) {
        // returns 2D screen coords with perspective scaling
        return this.dots.map(d => {
            let sx, sy;
            if (orth) {
                const factor = ((1 - d.z) / 10) + 0.92;
                sx = (d.x * scale) * factor + offset;
                sy = (d.y * scale) * factor + offset;
            } else {
                sx = (d.x * scale) + offset;
                sy = (d.y * scale) + offset;
            }
            return {
                sx,
                sy,
                // color: `rgb(${d.r},${d.g},${d.b})`,
                blasted: d.blasted,
                z: d.z,
                type: d.type,
                subtype: d.subtype
            };
        });
    }
    recolor(orth = false, scale = 120, offset = 350) {
        // returns 2D screen coords with perspective scaling

        let x = -1
        let y = -1
        let z = -1
        let st = -1
        this.dots.map(d => {
            d.blasted--

            if (d.selected == 1) {

                x = d.k
                y = d.t
                z = d.e


                st=d.subtype

            }

        })


        return this.dots.map(d => {
            let sx, sy;
            if (orth) {
                const factor = ((1 - d.z) / 10) + 0.92;
                sx = (d.x * scale) * factor + offset;
                sy = (d.y * scale) * factor + offset;
            } else {
                sx = (d.x * scale) + offset;
                sy = (d.y * scale) + offset;
            }
            if (d.selected == 1) {
                if (d.type == 1) {

                    return {
                        sx,
                        sy,
                        color: `rgb(${255},${0},${100})`,
                        blasted: d.blasted,
                        z: d.z,
                        type: d.type,
                        subtype: d.subtype
                    };
                } else if (d.type == 2) {

                    return {
                        sx,
                        sy,
                        color: `rgb(${0},${255},${0})`,
                        blasted: d.blasted,
                        z: d.z,
                        type: d.type,
                        subtype: d.subtype
                    };
                } else {

                    return {
                        sx,
                        sy,
                        color: `rgb(${0},${0},${0})`,
                        blasted: d.blasted,
                        z: d.z,
                        type: d.type,
                        subtype: d.subtype
                    };
                }
            } else {

                if (((x == d.k && (y == d.t || z == d.e)) || (y == d.t && (x == d.k || z == d.e)) || (z == d.e && (y == d.t || x == d.k)))) {

                    if (d.type != 1 && d.type != 2) {
                                let dx = Math.abs(x - d.k);
                                let dy = Math.abs(y - d.t);
                                let dz = Math.abs(z - d.e);

                                if (st == 2) {
                            if ((dx + dy + dz) <= 3) {

                                return {
                            sx,
                            sy,
                            color: `rgb(${255-(128*Math.cos(time))},${128+(128*Math.cos(time))},${128+(128*Math.sin(time))})`,
                            blasted: d.blasted,
                            z: d.z,
                            flash: 1,
                            type: d.type,
                            subtype: d.subtype
                        };
                            }
                        }else  if (st == 1) {

                            if ((dx + dy + dz) <= 2) {

                        return {
                            sx,
                            sy,
                            color: `rgb(${255-(128*Math.cos(time))},${128+(128*Math.cos(time))},${128+(128*Math.sin(time))})`,
                            blasted: d.blasted,
                            z: d.z,
                            flash: 1,
                            type: d.type,
                            subtype: d.subtype
                        };
                    }
                        }else{

                        return {
                            sx,
                            sy,
                            color: `rgb(${255-(128*Math.cos(time))},${128+(128*Math.cos(time))},${128+(128*Math.sin(time))})`,
                            blasted: d.blasted,
                            z: d.z,
                            flash: 1,
                            type: d.type,
                            subtype: d.subtype
                        };
                        }



                    } else {


                        if (d.type == 1) {

                            if (d.subtype == 1) {

                                return {
                                    sx,
                                    sy,
                                    color: `rgb(${250+(d.z*32)},${0},${200+(d.z*32)})`,
                                    z: d.z,
                                    type: d.type,
                                    subtype: d.subtype
                                };
                            } else if (d.subtype == 2) {

                                return {
                                    sx,
                                    sy,
                                    color: `rgb(${200+(d.z*32)},${50},${150+(d.z*32)})`,
                                    z: d.z,
                                    type: d.type,
                                    subtype: d.subtype
                                };
                            } else if (d.subtype == 3) {

                                return {
                                    sx,
                                    sy,
                                    color: `rgb(${200+(d.z*32)},${100},${100+(d.z*32)})`,
                                    z: d.z,
                                    type: d.type,
                                    subtype: d.subtype
                                };
                            }
                        } else if (d.type == 2) {

                            if (d.subtype == 1) {

                                return {
                                    sx,
                                    sy,
                                    color: `rgb(${190+(d.z*32)},${190+(d.z*32)},${0})`,
                                    blasted: d.blasted,
                                    z: d.z,
                                    type: d.type,
                                    subtype: d.subtype
                                };

                            } else if (d.subtype == 2) {

                                return {
                                    sx,
                                    sy,
                                    color: `rgb(${190+(d.z*32)},${190+(d.z*32)},${50})`,
                                    blasted: d.blasted,
                                    z: d.z,
                                    type: d.type,
                                    subtype: d.subtype
                                };


                            } else if (d.subtype == 3) {

                                return {
                                    sx,
                                    sy,
                                    color: `rgb(${190+(d.z*32)},${190+(d.z*32)},${100})`,
                                    blasted: d.blasted,
                                    z: d.z,
                                    type: d.type,
                                    subtype: d.subtype
                                };
                            }

                        }
                    }


                }



                if (d.type == 1) {


                    if (d.subtype == 1) {

                        return {
                            sx,
                            sy,
                            color: `rgb(${250+(d.z*32)},${0},${200+(d.z*32)})`,
                            z: d.z,
                            type: d.type,
                            subtype: d.subtype
                        };
                    } else if (d.subtype == 2) {

                        return {
                            sx,
                            sy,
                            color: `rgb(${200+(d.z*32)},${50},${150+(d.z*32)})`,
                            z: d.z,
                            type: d.type,
                            subtype: d.subtype
                        };
                    } else if (d.subtype == 3) {

                        return {
                            sx,
                            sy,
                            color: `rgb(${200+(d.z*32)},${100},${100+(d.z*32)})`,
                            z: d.z,
                            type: d.type,
                            subtype: d.subtype
                        };
                    }
                } else if (d.type == 2) {

                    if (d.subtype == 1) {

                        return {
                            sx,
                            sy,
                            color: `rgb(${190+(d.z*32)},${190+(d.z*32)},${0})`,
                            blasted: d.blasted,
                            z: d.z,
                            type: d.type,
                            subtype: d.subtype
                        };

                    } else if (d.subtype == 2) {

                        return {
                            sx,
                            sy,
                            color: `rgb(${190+(d.z*32)},${190+(d.z*32)},${50})`,
                            blasted: d.blasted,
                            z: d.z,
                            type: d.type,
                            subtype: d.subtype
                        };


                    } else if (d.subtype == 3) {

                        return {
                            sx,
                            sy,
                            color: `rgb(${190+(d.z*32)},${190+(d.z*32)},${100})`,
                            blasted: d.blasted,
                            z: d.z,
                            type: d.type,
                            subtype: d.subtype
                        };
                    }
                } else {
                    return {
                        sx,
                        sy,
                        color: `rgb(${128+(d.z*128)},${128+(d.z*128)},${128+(d.z*128)})`,
                        blasted: d.blasted,
                        z: d.z,
                        type: d.type,
                        subtype: d.subtype
                    };
                }
            }
        });
    }
    printSelf() {
        // Return only properties needed to reconstruct the dots
        const dotsData = this.dots.map(d => ({
            x: d.x,
            y: d.y,
            z: d.z,
            r: d.r,
            g: d.g,
            b: d.b,
            k: d.k,
            t: d.t,
            e: d.e,
            type: d.type,
            subtype: d.subtype ?? null,
            selected: d.selected ?? 0,
            blasted: d.blasted
        }));
        return JSON.stringify({
            dots: dotsData
        });
    }

    // --- New method: apply a saved state ---
    apply(jsonString) {
        const obj = JSON.parse(jsonString);
        if (!obj.dots || obj.dots.length !== this.dots.length) {
            console.warn("Invalid or mismatched data");
            return;
        }
        for (let i = 0; i < this.dots.length; i++) {
            const d = obj.dots[i];
            this.dots[i].x = d.x;
            this.dots[i].y = d.y;
            this.dots[i].z = d.z;
            this.dots[i].r = d.r;
            this.dots[i].g = d.g;
            this.dots[i].b = d.b;
            this.dots[i].k = d.k;
            this.dots[i].t = d.t;
            this.dots[i].e = d.e;
            this.dots[i].type = d.type;
            this.dots[i].subtype = d.subtype;
            this.dots[i].selected = d.selected;
            this.dots[i].blasted = d.blasted;
            this.dots[i].color = `rgb(${d.r}, ${d.g}, ${d.b})`;
        }
    }
}

// Add this method to Flex3DObject:
Flex3DObject.prototype.isPointInside = function(tip, radius = 4, orth = false, scale = 120, offset = 350) {
    // project and pair 3D <-> 2D
    const proj = this.dots.map(d => {
        let sx, sy;
        if (orth) {
            const factor = ((1 - d.z) / 10) + 0.92;
            sx = (d.x * scale) * factor + offset;
            sy = (d.y * scale) * factor + offset;
        } else {
            sx = (d.x * scale) + offset;
            sy = (d.y * scale) + offset;
        }
        return {
            d,
            sx,
            sy
        };
    });

    for (let p of proj) {
        let dx = tip.x - p.sx;
        let dy = tip.y - p.sy;
        if (dx * dx + dy * dy < radius * radius) {
            return p.d; // return the actual 3D dot
        }
    }
    return null;
};

// Add this method to Flex3DObject:
Flex3DObject.prototype.hover = function(tip, radius = 4, orth = false, scale = 120, offset = 350) {
    // project and pair 3D <-> 2D
    let printed = {}
    printed.d = {}
    printed.d.k = -1
    printed.d.t = -1
    printed.d.e = -1
    const proj = this.dots.map(d => {
        let sx, sy;
        if (orth) {
            const factor = ((1 - d.z) / 10) + 0.92;
            sx = (d.x * scale) * factor + offset;
            sy = (d.y * scale) * factor + offset;
        } else {
            sx = (d.x * scale) + offset;
            sy = (d.y * scale) + offset;
        }
        return {
            d,
            sx,
            sy
        };

    });

    for (let p of proj) {
        let dx = tip.x - p.sx;
        let dy = tip.y - p.sy;
        if (dx * dx + dy * dy < radius * radius) {
            printed = p; // return the actual 3D dot
        }
    }

    if (printed.d.k > -1) {

        canvas_context.fillStyle = 'white'
        canvas_context.strokeStyle = 'Black'
        canvas_context.font = '30px arial'
        canvas_context.fillText(`${printed.d.k}, ${printed.d.t}, ${printed.d.e}`, TIP_engine.x, TIP_engine.y)
        canvas_context.strokeText(`${printed.d.k}, ${printed.d.t}, ${printed.d.e}`, TIP_engine.x, TIP_engine.y)
        // return null;

    }
};


Flex3DObject.prototype.draw = function(ctx, opts = {}) {
    const {
        orth = false,
            scale = 120,
            offset = 350,
            radius = 3
    } = opts;

    for (let t = 0; t < this.links.length; t++) {
        this.links[t].draw()
    }
    // Project into 2D space
    let dots2d = this.recolor(orth, scale, offset);

    // Depth sort (draw farthest first)
    dots2d.sort((a, b) => a.z - b.z);

    for (let p of dots2d) {
        canvas_context.beginPath();
        if (p.type != 1 && p.type != 2) {

            if (p.blasted >= 1) {

                canvas_context.arc(p.sx, p.sy, ((radius + (p.z / 3)) / 3) + (p.blasted / 4), 0, Math.PI * 2);
            } else if (p.flash == 1) {

                canvas_context.arc(p.sx, p.sy, ((radius + (p.z / 3)) / 3) + 1, 0, Math.PI * 2);
            } else {

                canvas_context.arc(p.sx, p.sy, (radius + (p.z / 3)) / 3, 0, Math.PI * 2);
            }
        } else {

            if (p.subtype == 1) {
                canvas_context.arc(p.sx, p.sy, (radius + p.z) / .8, 0, Math.PI * 2);
            } else if (p.subtype == 2) {
                let poly = new Polygon(p.sx, p.sy, (radius + (p.z / 2)) / .5, p.color, 3, 0, 0, ((time) * Math.PI * 2) / 10)
                poly.draw()
            } else if (p.subtype == 3) {
                let poly = new Polygon(p.sx, p.sy, (radius + (p.z / 2)) / .5, p.color, 6, 0, 0, -((time) * Math.PI * 2) / 10)
                poly.draw()
            }
        }
        canvas_context.fillStyle = p.color;
        if (p.blasted >= 1) {
            canvas_context.fillStyle = blastcolors[p.blasted];


        }
        canvas_context.fill();
    }
};


let orth = false

let grid = new Flex3DObject(7)
let time = 0
let turnjack = 0
let turnjack2 = 0
let turned2 = 0
let turned = 0

const blastcolors = [
    // White to Yellow
    "#FFFFFF", // white
    "#FFFFCC",
    "#FFFF99",
    "#FFFF66",
    "#FFFF33",
    "#FFFF00", // yellow

    // Yellow to Orange
    "#FFEA00",
    "#FFD400",
    "#FFBF00",
    "#FFA500", // orange

    // Orange to Red
    "#FF8C00",
    "#FF6600",
    "#FF3300",
    "#FF1900",
    "#FF0000", // red

    // Red (darkening)
    "#E00000",
    "#C00000",
    "#A00000",
    "#800000",
    "#600000",

    // Fade to black (last 5)
    "#400000",
    "#300000",
    "#200000",
    "#100000",
    "#000000"
];


let globalRoom = Math.floor(Math.random() * 9999)
    // let b = new Board()
    let startgame = 0

    let roomslist = []
    let goRect = new Rectangle(500, 500, 100, 100, "#00ff00")

    class Numbox {
        constructor() {
            this.number = globalRoom
            this.pressed = 0
        }
        draw() {
            // ////console.log(keysPressed)
            if (this.number < 999) {
                if (keysPressed['1']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                    }
                    this.number = parseInt(this.number + `1`, 10)
                    keysPressed['1'] = false
                }
                if (keysPressed['2']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                    }
                    this.number = parseInt(this.number + `2`, 10)
                    keysPressed['2'] = false
                }
                if (keysPressed['3']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                    }
                    this.number = parseInt(this.number + `3`, 10)
                    keysPressed['3'] = false
                }
                if (keysPressed['4']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                    }
                    this.number = parseInt(this.number + `4`, 10)
                    keysPressed['4'] = false
                }
                if (keysPressed['5']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                    }
                    this.number = parseInt(this.number + `5`, 10)
                    keysPressed['5'] = false
                }
                if (keysPressed['6']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                    }
                    this.number = parseInt(this.number + `6`, 10)
                    keysPressed['6'] = false
                }
                if (keysPressed['7']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                    }
                    this.number = parseInt(this.number + `7`, 10)
                    keysPressed['7'] = false
                }
                if (keysPressed['8']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                    }
                    this.number = parseInt(this.number + `8`, 10)
                    keysPressed['8'] = false
                }
                if (keysPressed['9']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                    }
                    this.number = parseInt(this.number + `9`, 10)
                    keysPressed['9'] = false
                }
                if (keysPressed['0']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                    }
                    this.number = parseInt(this.number + `0`, 10)
                    keysPressed['0'] = false
                }
            } else {
                if (keysPressed['1']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                        this.number = parseInt(this.number + `1`, 10)
                        keysPressed['1'] = false
                    }
                }
                if (keysPressed['2']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                        this.number = parseInt(this.number + `2`, 10)
                        keysPressed['2'] = false
                    }
                }
                if (keysPressed['3']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                        this.number = parseInt(this.number + `3`, 10)
                        keysPressed['3'] = false
                    }
                }
                if (keysPressed['4']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                        this.number = parseInt(this.number + `4`, 10)
                        keysPressed['4'] = false
                    }
                }
                if (keysPressed['5']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                        this.number = parseInt(this.number + `5`, 10)
                        keysPressed['5'] = false
                    }
                }
                if (keysPressed['6']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                        this.number = parseInt(this.number + `6`, 10)
                        keysPressed['6'] = false
                    }
                }
                if (keysPressed['7']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                        this.number = parseInt(this.number + `7`, 10)
                        keysPressed['7'] = false
                    }
                }
                if (keysPressed['8']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                        this.number = parseInt(this.number + `8`, 10)
                        keysPressed['8'] = false
                    }
                }
                if (keysPressed['9']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                        this.number = parseInt(this.number + `9`, 10)
                        keysPressed['9'] = false
                    }
                }
                if (keysPressed['0']) {
                    if (this.pressed == 0) {
                        this.pressed = 1
                        this.number = 0
                        this.number = parseInt(this.number + `0`, 10)
                        keysPressed['0'] = false
                    }
                }

            }
            if (keysPressed['Backspace']) {
                this.number = 0
            }
            canvas_context.clearRect(0,0,700,700)
            canvas_context.font = "20px arial"
            canvas_context.fillStyle = "white"
            canvas_context.fillText("Type in a number and press the button to select a room", 100, 100)
            canvas_context.fillText("Magenta goes first", 100, 150)
            canvas_context.fillText("Room: " + this.number, 100, 200)
            canvas_context.fillText("Press Backspace to reset room number", 100, 250)
            canvas_context.fillText("Units move in straight lines.", 100, 290)
            canvas_context.fillText("Circles and triangles can capture, triangles detonate", 100, 330)
            canvas_context.fillText("Hexagons leave a trail of circles and duplicate as they move", 100, 370)

            canvas_context.fillText("Active rooms:", 100, 410)
            goRect.draw()
            // ////console.log(roomslist)
            for (let t = 0; t < roomslist.length; t++) {
                canvas_context.font = "20px arial"
                canvas_context.fillStyle = "white"
                if (roomslist[t][0] != 0) {

                    canvas_context.fillText("Room: " + roomslist[t][0] + "     " + roomslist[t][1] + '/' + '2', 100, 430 + (t * 22))
                }

            }

        }
    }





let roombox = new Numbox()

let indicator = 0
let indicator2 = 0


function main() {
    indicator2++
            if (indicator2 >5) {
                indicator2 = 0
                let pson = {}
                pson.queryTournament = 1

                ws.send(JSON.stringify(pson))
            }


    if(startgame == 1){


    }else{
        roombox.draw()

        let pson = {}
        pson.room = roombox.number
        ws.send(JSON.stringify(pson))
        return
    }
    time += .25

    canvas_context.clearRect(0, 0, canvas.width, canvas.height)


    // grid.draw()
    // canvas_context.clearRect(0, 0, canvas.width, canvas.height);


    canvas_context.fillText("Room: " + roombox.number, 500, 40)


    grid.draw(canvas_context, {
        orth: false,
        scale: 120,
        offset: canvas.width / 2,
        radius: 5
    });


    if (keysPressed['w']) {
        grid.rotateX(.05)
    }
    if (keysPressed['s']) {
        grid.rotateX(-.05)
    }

    if (keysPressed['a']) {
        grid.rotateY(.05)
    }
    if (keysPressed['d']) {
        grid.rotateY(-.05)
    }

    if (keysPressed['q']) {
        grid.rotateZ(.05)

    }
    if (keysPressed['e']) {
        grid.rotateZ(-.05)

    }

    canvas_context.fillStyle = 'white'
    canvas_context.strokeStyle = 'Black'
    canvas_context.font = '30px arial'
    let redc = 0
    let greenc = 0
    for (let t = 0; t < grid.dots.length; t++) {
        if (grid.dots[t].type == 1) {
            redc++
        }
        if (grid.dots[t].type == 2) {
            greenc++
        }
    }
    canvas_context.fillText(`Magenta: ${redc}, Yellow: ${greenc}`, 20, 40)
    canvas_context.strokeText(`Magenta: ${redc}, Yellow: ${greenc}`, 20, 40)
    if (grid.turn == -1) {
        canvas_context.fillText(`Magenta Turn`, 20, 70)
        canvas_context.strokeText(`Magenta Turn`, 20, 70)

        turnjack = 0
        turned = 0




        // turnjack2++ //ai toggle
        if (turnjack2 > 10 && turned2 == 0) {
            console.log(turned2)
            for (let t = 0; t < grid.dots.length; t++) {
                if (grid.dots[t].type == 1) {

                    if (Math.random() < .04) {
                        let p = new Point((grid.dots[t].x * 120) + 350, (grid.dots[t].y * 120) + 350)
                        const hit = grid.isPointInside(p, 5); // 12px tolerance
                        if (hit.type == 1 && grid.turn == -1) {
                            grid.dots.map(d => {
                                d.selected = -1
                            })

                            if (hit) {
                                selected = hit;
                                // console.log("Selected point:", hit);
                                hit.selected = 1
                                turned2 = 1

                                let x = hit.k
                                let z = hit.e
                                let y = hit.t

                                grid.dots.map(d => {
                                    if (grid.turn == -1 && d.type == 1) {
                                        if (d.selected == 2) {

                                            if (d.type > 0 && hit.type != d.type) {

                                                if ((x == d.k && (y == d.t || z == d.e)) || (y == d.t && (x == d.k || z == d.e)) || (z == d.e && (y == d.t || x == d.k))) {
                                                    hit.type = d.type
                                                    hit.subtype = d.subtype
                                                    d.type = 0
                                                    d.subtype = 0
                                                    d.selected = 0
                                                    hit.selected = 0
                                                    grid.turn *= -1
                                                }
                                            }
                                        }
                                    } else if (grid.turn == 1 && d.type == 2) {
                                        if (d.selected == 2) {
                                            if (d.type > 0 && hit.type != d.type) {

                                                if ((x == d.k && (y == d.t || z == d.e)) || (y == d.t && (x == d.k || z == d.e)) || (z == d.e && (y == d.t || x == d.k))) {
                                                    hit.type = d.type
                                                    hit.subtype = d.subtype
                                                    d.type = 0
                                                    d.subtype = 0
                                                    d.selected = 0
                                                    hit.selected = 0
                                                    grid.turn *= -1
                                                }
                                            }
                                        }
                                    }
                                })


                                hit.r = 1
                                hit.g = 1
                                hit.b = 1
                            } else {
                                selected = null;
                            }
                        }




                    }


                }
            }
        } else if (turned2 == 1) {

            for (let t = 0; t < grid.dots.length; t++) {
                // if(grid.dots[t].type == 2){

                if (Math.random() < 1) {

                    let zs = grid.dots[Math.floor(Math.random() * grid.dots.length)]
                    let p = new Point((zs.x * 120) + 350, (zs.y * 120) + 350)
                    const hit = grid.isPointInside(p, 5); // 12px tolerance
                    // if(hit.type == 0 ){
                    //     return
                    // }
                    if (hit.type == 1 && grid.turn == -1) {

                        let sup = 0
                        grid.dots.map(d => {
                            // if(d.selected == 1){

                            //     // d.selected = 2
                            //     // sup = 1
                            // }else{

                            d.selected = -1
                            // }
                        })

                    } else if (hit.type == 2 && grid.turn == 1) {

                        let sup = 0
                        grid.dots.map(d => {
                            // if(d.selected == 1){

                            //     // d.selected = 2
                            //     // sup = 1
                            // }else{

                            d.selected = -1
                            // }
                        })

                    } else {

                        let sup = 0
                        grid.dots.map(d => {
                            if (d.selected == 1) {

                                d.selected = 2
                                sup = 1
                            } else {

                                d.selected = -1
                            }
                        })


                        if (sup == 0) {

                            return
                        }
                    }


                    if (hit) {
                        selected = hit;
                        console.log("Selected point:", hit);
                        hit.selected = 1

                        let x = hit.k
                        let z = hit.e
                        let y = hit.t

                        grid.dots.map(d => {
                            if (grid.turn == -1 && d.type == 1) {
                                if (d.selected == 2) {
                                    if (d.type > 0 && hit.type != d.type) {

                                        if ((x == d.k && (y == d.t || z == d.e)) || (y == d.t && (x == d.k || z == d.e)) || (z == d.e && (y == d.t || x == d.k))) {
                                            hit.type = d.type
                                            hit.subtype = d.subtype
                                            d.type = 0
                                            d.subtype = 0
                                            d.selected = 0
                                            hit.selected = 0
                                            grid.turn *= -1
                                        }
                                    }
                                }
                            } else if (grid.turn == 1 && d.type == 2) {
                                if (d.selected == 2) {
                                    if (d.type > 0 && hit.type != d.type) {

                                        if ((x == d.k && (y == d.t || z == d.e)) || (y == d.t && (x == d.k || z == d.e)) || (z == d.e && (y == d.t || x == d.k))) {
                                            hit.type = d.type
                                            hit.subtype = d.subtype
                                            d.type = 0
                                            d.subtype = 0
                                            d.selected = 0
                                            hit.selected = 0
                                            grid.turn *= -1
                                        }
                                    }
                                }
                            }
                        })


                        hit.r = 1
                        hit.g = 1
                        hit.b = 1
                    } else {
                        selected = null;
                    }
                }

                // }
            }

        }

    } else {

        turnjack2 = 0
        turned2 = 0
        canvas_context.fillText(`Yellow Turn`, 20, 70)
        canvas_context.strokeText(`Yellow Turn`, 20, 70)
        // turnjack++ //ai toggle
        if (turnjack > 10 && turned == 0) {
            console.log(turned)
            for (let t = 0; t < grid.dots.length; t++) {
                if (grid.dots[t].type == 2) {

                    if (Math.random() < .04) {
                        let p = new Point((grid.dots[t].x * 120) + 350, (grid.dots[t].y * 120) + 350)
                        const hit = grid.isPointInside(p, 5); // 12px tolerance
                        if (hit.type == 2 && grid.turn == 1) {
                            grid.dots.map(d => {
                                d.selected = -1
                            })

                            if (hit) {
                                selected = hit;
                                // console.log("Selected point:", hit);
                                hit.selected = 1
                                turned = 1

                                let x = hit.k
                                let z = hit.e
                                let y = hit.t

                                grid.dots.map(d => {
                                    if (grid.turn == -1 && d.type == 1) {
                                        if (d.selected == 2) {

                                            if (d.type > 0 && hit.type != d.type) {

                                                if ((x == d.k && (y == d.t || z == d.e)) || (y == d.t && (x == d.k || z == d.e)) || (z == d.e && (y == d.t || x == d.k))) {
                                                    hit.type = d.type
                                                    hit.subtype = d.subtype
                                                    d.type = 0
                                                    d.subtype = 0
                                                    d.selected = 0
                                                    hit.selected = 0
                                                    grid.turn *= -1
                                                }
                                            }
                                        }
                                    } else if (grid.turn == 1 && d.type == 2) {
                                        if (d.selected == 2) {
                                            if (d.type > 0 && hit.type != d.type) {

                                                if ((x == d.k && (y == d.t || z == d.e)) || (y == d.t && (x == d.k || z == d.e)) || (z == d.e && (y == d.t || x == d.k))) {
                                                    hit.type = d.type
                                                    hit.subtype = d.subtype
                                                    d.type = 0
                                                    d.subtype = 0
                                                    d.selected = 0
                                                    hit.selected = 0
                                                    grid.turn *= -1
                                                }
                                            }
                                        }
                                    }
                                })


                                hit.r = 1
                                hit.g = 1
                                hit.b = 1
                            } else {
                                selected = null;
                            }
                        }




                    }


                }
            }
        } else if (turned == 1) {

            for (let t = 0; t < grid.dots.length; t++) {
                // if(grid.dots[t].type == 2){

                if (Math.random() < 1) {

                    let zs = grid.dots[Math.floor(Math.random() * grid.dots.length)]
                    let p = new Point((zs.x * 120) + 350, (zs.y * 120) + 350)
                    const hit = grid.isPointInside(p, 5); // 12px tolerance
                    // if(hit.type == 0 ){
                    //     return
                    // }
                    if (hit.type == 1 && grid.turn == -1) {

                        let sup = 0
                        grid.dots.map(d => {
                            // if(d.selected == 1){

                            //     // d.selected = 2
                            //     // sup = 1
                            // }else{

                            d.selected = -1
                            // }
                        })

                    } else if (hit.type == 2 && grid.turn == 1) {

                        let sup = 0
                        grid.dots.map(d => {
                            // if(d.selected == 1){

                            //     // d.selected = 2
                            //     // sup = 1
                            // }else{

                            d.selected = -1
                            // }
                        })

                    } else {

                        let sup = 0
                        grid.dots.map(d => {
                            if (d.selected == 1) {

                                d.selected = 2
                                sup = 1
                            } else {

                                d.selected = -1
                            }
                        })


                        if (sup == 0) {

                            return
                        }
                    }


                    if (hit) {
                        selected = hit;
                        console.log("Selected point:", hit);
                        hit.selected = 1

                        let x = hit.k
                        let z = hit.e
                        let y = hit.t

                        grid.dots.map(d => {
                            if (grid.turn == -1 && d.type == 1) {
                                if (d.selected == 2) {
                                    if (d.type > 0 && hit.type != d.type) {

                                        if ((x == d.k && (y == d.t || z == d.e)) || (y == d.t && (x == d.k || z == d.e)) || (z == d.e && (y == d.t || x == d.k))) {
                                            hit.type = d.type
                                            hit.subtype = d.subtype
                                            d.type = 0
                                            d.subtype = 0
                                            d.selected = 0
                                            hit.selected = 0
                                            grid.turn *= -1
                                        }
                                    }
                                }
                            } else if (grid.turn == 1 && d.type == 2) {
                                if (d.selected == 2) {
                                    if (d.type > 0 && hit.type != d.type) {

                                        if ((x == d.k && (y == d.t || z == d.e)) || (y == d.t && (x == d.k || z == d.e)) || (z == d.e && (y == d.t || x == d.k))) {
                                            hit.type = d.type
                                            hit.subtype = d.subtype
                                            d.type = 0
                                            d.subtype = 0
                                            d.selected = 0
                                            hit.selected = 0
                                            grid.turn *= -1
                                        }
                                    }
                                }
                            }
                        })


                        hit.r = 1
                        hit.g = 1
                        hit.b = 1
                    } else {
                        selected = null;
                    }
                }

                // }
            }

        }

    }
    if (redc == 0) {
        canvas_context.fillText(`Yellow Wins`, 20, 650)
        canvas_context.strokeText(`Yellow Wins`, 20, 650)

    }
    if (greenc == 0) {
        canvas_context.fillText(`Magenta Wins`, 20, 650)
        canvas_context.strokeText(`Magenta Wins`, 20, 650)

    }

    grid.hover(TIP_engine)
    indicator++
                    if (indicator > 4) { 
                        indicator = 0
                        let pson = {}
                        pson.pinging = 1
                        ws.send(JSON.stringify(pson))
                    }

}

// })


let last = {}
last.k = -1
last.t = -1
last.e = -1

// let ws
const protocol = window.location.protocol === "https:" ? "wss" : "ws";
const ws = new WebSocket(`${protocol}://${window.location.host}/path-if-any`);
let playerID = -1 //Math.floor(Math.random()*2)

Socketize(ws)


let newboard = 0

function Socketize(ws) {
    ws.addEventListener("message", (event) => {
        let raw = event.data;

        // Strip "Echo: " prefix if present
        if (raw.startsWith("Echo: ")) {
            raw = raw.replace(/^Echo:\s*/, '');
        }

        let parsed;
        try {
            parsed = JSON.parse(raw);
        } catch (e) {
            console.error("Invalid JSON received:", raw);
            return;
        }

        console.log(parsed);

        // Handle board update
        if (parsed.tile > -1) {
            console.log('Updating board');
            grid.apply(parsed.board);
            grid.turn *= -1
            // stoneclick.play();
        }
        // Handle room list
        else if (parsed.roomlist) {
            roomslist = parsed.roomlist;
        }
        // Fallback example drawing
        else {
            if(parsed.room == roombox.number || parsed.room == globalRoom){
                let rect = new Rectangle(0, 0, 20, 20, "#00FF00"); 
            rect.draw();
            }
        }
    });
}
</script>

<div id="dog-image-container">

</div id="go">

</html>